<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>




<title>Perl Unicode Essentials</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="pod2s5 0.08" />
<meta name="generator" content="S5" />
<meta name="version" content="S5 1.1 hacked by tchrist" />
<meta name="presdate" content="Tuesday, 28 July 2011" />
<meta name="author" content="Tom Christiansen" />
<meta name="company" content="&nbsp;" />
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<link rel="stylesheet" href="ui/default/slides.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/default/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/default/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/default/opera.css" type="text/css" media="projection" id="operaFix" />

<!-- embedded styles -->
<style type="text/css" media="all">
.imgcon {width: 525px; margin: 0 auto; padding: 0; text-align: center;}
#anim {width: 270px; height: 320px; position: relative; margin-top: 0.5em;}
#anim img {position: absolute; top: 42px; left: 24px;}
img#me01 {top: 0; left: 0;}
img#me02 {left: 23px;}
img#me04 {top: 44px;}
img#me05 {top: 43px;left: 36px;}
</style>
<!-- S5 JS -->
<script src="ui/default/slides.js" type="text/javascript"></script>
<!--
   tom AT cpan.org:
   this will not work, it's not contained
   in the downloadable S5
   <script src="/mint/?js" type="text/javascript"></script></head>
-->
</head><body>




<div class="layout">

<div id="controls"></div>
<div id="currentSlide"></div>
<div id="header"></div>
<div id="footer">
<h1>OSCON &#8226; Tuesday, 28 July 2011</h1>
<h2>Perl Unicode Essentials</h2></div>
</div><div class="slide">
<h1>🐪 Perl Unicode Essentials

</h1><blockquote>

<p align=center> <font size="6">Growing explosively over the last decade, most text today is
now in Unicode, with some corpora reaching 100% Unicode.  This tutorial
shows Perl programmers how to write scripts to handle Unicode data
reliably.  </font></p>

</blockquote>


<p align=left>

<h2 align=center>
    <font size="7">
Tom Christiansen<BR>
    </font>
    <font size="6">
&lt;tchrist@perl.com&gt;
    </font>
</h2>

<p align=center>
    <code>
    <font face="Monaco, mono" size="5">
        😈  ¡ƨdləɥ ƨᴉɥʇ ədoɥ puɐ ʻλɐp əɔᴉu ɐ əʌɐɥ ʻʞɔnl poo⅁   😈 
    </font>
    </code>
</p>


</div>
<div class="slide">
<h1>What <i>is</i> this?

</h1><ul><li level="1">Get the current version from here:

<pre> http://training.perl.com/OSCON2011/index.html </pre></li><li level="1">I’ll often use 🐪  as an abbreviation for <i>Perl</i>, and sometimes
for <i>perl</i> — as in, “I’m running 🐪  v5.14.”

</li><li level="1">See <i>Appendix 1: Fonts</i> at the end of this talk for instructions on font set-up.

</li><li level="1">These slides was written in pod using <i>vi</i>, with the help of a
score of 🐪 Unicode tools available via the link in <i>Appendix 2: Tools</i>.

</li><li level="1">This slide show was built using <code>Pod::S5</code> by Tom Linden,
which in turn uses <code>S5</code> by Eric Meyer.  Slideshow controls appears
if you hover near the bottom right corner.

</li><li level="1">I’ve used next to no HTML tricks here; nearly all 
fancy‐<i>qua</i>‐weird stuﬀ you see here is actually Unicode.

</li></ul></div>
<div class="slide">
<h1>Welcome to Unicode!

</h1><ul><li level="1">Unicode isn’t just “here” — Unicode is now 20 years old, and it’s
here to stay.

</li><li level="1"><i>Every</i> programmer needs to understand it, at least a little.

</li><li level="1">Unicode is <i>not</i> just for <i>non</i>‐English; look closely at this page.

<li>This talk has its roots in a <a href="http://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default/6163129#6163129" target="_blank">StackOverﬂow posting</a>.

</li><li level="1">I have a whole ’nother talk on <b>Thursday at 4:10pm in Portland 256</b> entirely dedicated
to Unicode in Perl regular expressions. 

</li><li level="1">Therefore, this talk won’t talk <i>too</i> much about regexes, 
but if we run out of materials here this morning before we run out of morning, 
I’ll go through some of those here.  

</li></ul></div>
<div class="slide">
<h1>The Bad News

</h1><ul><li level="1">There exists no:

<ul><li level="1">envariable to set

</li><li level="1">CLI switch to turn on

</li><li level="1">pragma to declare

</li><li level="1">nor module to load

</li></ul><p>that will somehow “enable Unicode by default” in your code.  

</p></li><li level="1">The very idea is a category error, because so long as you think of
Unicode as merely “like ASCII/Latin1/CP1252/anything, but with more
characters”, you will never grasp it. That’s closer to ISO‐10646, but
Unicode is <i>much</i> more than that.

</li><li level="1">No matter how much boilerplate you introduce, you are never going
to get your head into Unicode until you stop thinking of it as nothing
more than a bigger character set, which means you are never going to do
things “right”.

</li></ul></div>
<div class="slide">
<h1>Surprise!

</h1><ul><li level="1"><i>Besides</i> having more characters, Unicode <i>also</i> includes 

<ul><li level="1">rules for casemapping and casefolding 

</li><li level="1">grapheme clusters, including combining characters

</li><li level="1">several diﬀerent kinds of normalization forms

</li><li level="1">highly customizable rules for collation

</li><li level="1">rules for word‐ <i>&</i> line‐breaking

</li><li level="1">special rules for regular expressions

</li><li level="1">1000s of properties, including names and scripts

</li><li level="1">numeric equivalences (<i>e.g.</i>, telling you that U+216B, “Ⅻ”, has the value 12)

</li><li level="1">print widths

</li><li level="1">bidirectionality

</li><li level="1">glyph variants

</li><li level="1"><i>&</i> much, <i>much</i> more‼ 

</li></ul></li></ul></div>
<div class="slide">
<h1>The Good News 😻 

</h1><ul><li level="1">The good news is 🐪  currently has <i><b>the</b></i> best Unicode support of any
programming language.  If you think <i>we’ve</i> got it bad,
just try any of the other guys. Come to my <b>Unicode Support Shootout</b> talk at 5pm
on Thursday, and see why.

</li><li level="1">That doesn’t mean Unicode in Perl (or anything) is hassle‐free.  
A small set of common blunders exist that are far too is easy to get stuck on, 
seemingly forever.

</li><li level="1">This tutorial is front‐loaded to get across a few simple, basic
settings so that <i>that</i> never happens to you.  It’s to make the easy
stuﬀ easy.

</li><li level="1">There <i>is</i> hard stuﬀ involved with Unicode — and for the most
part, you <i>can</i> do them in 🐪.  It just takes more work<i>&</i>care that 
the easy stuff.

</li><li level="1">Most of the really hard ones are beyond the scope of this tutorial, 
but we may touch on a few of those toward the end.

</li></ul></div>
<div class="slide">
<h1>Included 🐪 Unicode Tools

</h1><li level="1">I’ve included a directory full of 🐪 scripts which I ﬁnd useful in <i>Appendix 2: Tools</i>:

<ul><li level="1">Probing the UCD:
<code>unichars</code>,
<code>uninames</code>,
<code>uniprops</code>

</li><li level="1">For use with the <code>charnames</code> pragma:
<code>unicore/html_alias.pl</code>

</li><li level="1">Unix tool rewrites:
<code>tcgrep</code>,
<code>ucsort</code>,
<code>unifmt</code>,
<code>unilook</code>,
<code>uniquote</code> (a better <code>cat ‑v</code> or <code>od</code>),
<code>uniwc</code>

</li><li level="1">Normalization ﬁlters and tools:
<code>nfc</code>,
<code>nfd</code>,
<code>nfkc</code>,
<code>nfkd</code>, 
plus <code>nfcheck</code>

</li><li level="1">Casing and font‐fun ﬁlters:
<code>uc</code>,
<code>lc</code>,
<code>tc</code>, 
plus <code>titulate</code>;
<code>unifont</code>,
<code>leo</code>,
<code>unicaps</code>,
<code>uninarrow</code>,
<code>uniwide</code>,
<code>unisubs</code>,
<code>unisupers</code>

</li><li level="1">Test/demo code:
<code>es-sort</code>,
<code>hantest</code>,
<code>havshpx</code>,
<code>hypertest</code>,
<code>nunez</code> (should be called <code>núñez</code> or even better, <code>búsqueda-libre</code>, but for ﬁlesys issues)

</li></ul></div>
<div class="slide">
<h1>🐪 Unicode Tools: Setup

</h1><ul><li level="1">If you grab the tools, you can various examples of them I mention in this talk. 

</li><li level="1">When I run them, I have this environment set up:

<ul><li level="1">for <i>bash</i>

<pre> $ export PERL_UNICODE=CSD      # but see below
 $ export LESS=MQeicsnf
 $ alias pc 'perl5.14.0 -Mcharnames=:full,:short,latin,greek -E'
 $ alias ug=uninames
 $ alias um='ucsort | less -r' </pre></li><li level="1">for <i>tcsh</i>

<pre> % alias um 'ucsort | less -r'
 % alias ug uninames
 % alias pc 'perl5.14.0 -Mcharnames=:full,:short,latin,greek -E'
 % setenv PERL_UNICODE CSD
 % export LESS MQeicsnf </pre></li></ul></li></ul></div>
<div class="slide">
<h1>🐪 Unicode Tools: 𝔈𝔵𝔢𝔪𝔭𝔩𝔦 𝔊𝔯𝔞𝔱𝔦𝔞 

</h1><p>Here are simple examples to play with:

</p><pre> % pc 'say "\N{long s} \N{ae} \N{Omega} \N{omega}" \N{UPWARDS ARROW}'

 % echo exempli gratia | tc | unifont 

 % tcgrep -n '\P{ASCII}' pue.pod | uniquote -x | less
 % tcgrep -n '\P{ASCII}' pue.pod | uniquote -v | less

 % echo you are not expected to read this | leo

 % echo these are small caps | tc | unicaps
 % echo supers                    | unisupers
 % echo 123a                      | unisubs </pre></div>
<div class="slide">
<h1>🐪 Unicode Tools: 𝔈𝔵𝔢𝔪𝔭𝔩𝔦 𝔊𝔯𝔞𝔱𝔦𝔞  <i>(cont¹…)</i>

</h1><p>Here are more interesting examples to play with:

</p><pre> % uninames latin ligat
 % uninames SIGN -arabic
 % uninames arrow -combining

 % uniprops 'MICRO SIGN'
 % uniprops -a 2010

 % unichars '\pL' '\p{Greek}'
 % unichars '\pL' '\p{Greek}' | um
 % unichars '\p{Age=6.0}'     | um
 % unichars -gasn NUM

 % unilook glob
 % unilook /glob
 % unilook -v '\pM'
 % unilook -v '\N{acute}'
 % unilook -v whom
 % unilook -vpn run </pre></div>
<div class="slide">
<h1>Basic Recommendations

</h1><ul><li level="1">Set your <code>PERL_UNICODE</code> envariable to <b><code>AS</code></b>. This makes all 🐪
scripts decode <code>@ARGV</code> as UTF‐8 strings, and sets the encoding of all
three of stdin, stdout, and stderr to UTF‐8.   You may have to turn it
oﬀ at times, though.  I don’t recommend <b><code>D</code></b>.

</li><li level="1">At the top of your source ﬁle (program, module, library,
<code>do</code>hickey), prominently assert that you are running perl version 5.12
or better via:

<pre> use v5.12;  # minimal for unicode_strings feature
 use v5.14;  # optimal for unicode_strings feature </pre></li><li level="1">Declare this source unit as UTF‐8. Once upon a time, this pragma did
other things, but it now serves this singular purpose alone and no other:

<pre> use utf8; </pre></li></ul></div>
<div class="slide">
<h1>Basic Recommendations <i>(cont¹…)</i>

</h1><ul><li level="1">Enable (or reënable) strictures.

<pre> use strict; </pre></li><li level="1">Enable compiler warnings; we’ll get to runtime warnings in a moment.

<pre> use warnings; </pre></li><li level="1">Fatalize UTF‐8 warnings.

<pre> use warnings qw( FATAL utf8 ); </pre></li><li level="1">Under v5.14, the <code>utf8</code> warning class comprises three subwarnings
— <code>nonchar</code>, <code>surrogate</code>, and <code>non_unicode</code> — which you may sometimes
wish to exert greater (<i>i.e.</i>, separate) control over.

<pre> no warnings "non_unicode"; </pre></li></ul></div>
<div class="slide">
<h1>Basic Recommendations <i>(cont²…)</i>

</h1><ul><li level="1">Declare that ﬁlehandles opened <i>within this lexical scope but not
elsewhere</i> are in UTF‐8, until and unless you say otherwise.  The
<code>:std</code> adds in <code>STDIN</code>, <code>STDOUT</code>, and <code>STDERR</code>. 
This critical step
implicitly decodes incoming data and encodes outgoing data as UTF‐8.

<pre> use open qw( :encoding(UTF-8) :std ); </pre></li><li level="1">Enable named characters via <code>\N{<i>CHARNAME</i>}</code>.

<pre> use charnames qw( :full ); </pre></li><li level="1">If you have a <code>DATA</code> handle, you must explicitly set its
encoding. If you want this to be UTF‐8, then say:

<pre> binmode(DATA, ":encoding(UTF-8)"); </pre></li></ul></div>
<div class="slide">
<h1>Unicode Template

</h1><ul><li level="1">The next few slides show how I start all my 🐪 code these days.

</li><li level="1">They combine the previous directives and add a few niceties.

</li><li level="1">Some of the later elements may get omitted in some code, but
not the earlier ones.

</li><li level="1">The <code>#!</code> line is debatable. Consider it a shortcut for whatever
you need on your system: I try not to inﬂict <i>perlrun</i>’s
<code>eval exec</code> hack on people. 😒 

</li><li level="1">🐜  Unfortunately, 

<a href="https://rt.cpan.org/Public/Bug/Display.html?id=54777" target=_blank>
a known bug</a>
prevents the <code>open</code> pragma from working
correctly if you’ve also used the <code>autodie</code> pragma:

<pre> https://rt.cpan.org/Public/Bug/Display.html?id=54777 </pre></li></ul></div>
<div class="slide">
<h1>Unicode Template: Pragmas

</h1><p>Don’t take my <code>#!</code> here too seriously; it has Issues.

</p><pre> #!/usr/bin/env perl

 use v5.14;
 use utf8;

 use strict;
 use autodie;
 use warnings; 

 use warnings    qw&lt; FATAL utf8 >;
 use open        qw&lt; :std :encoding(UTF-8) >;
 use charnames   qw&lt; :full >;
 use feature     qw&lt; unicode_strings >; </pre></div>
<div class="slide">
<h1>Unicode Template: Modules

</h1><p>The ﬁrst of these is almost always needed; the rest, not so much.

</p><pre> use Unicode::Normalize  qw&lt; NFD NFC >;
 use Encode              qw&lt; encode decode >;

 use Carp                qw&lt; carp croak confess cluck >;
 use File::Basename      qw&lt; basename >;

 $0 = basename($0);  # shorter messages </pre></div>
<div class="slide">
<h1>Unicode Template: DATA, @ARGV

</h1><p>Don’t make <code>$|</code> hot if you have a lot of output on <code>STDOUT</code>.

</p><pre> binmode(DATA, ":encoding(UTF-8)");
 
 # This works like perl -CA: note that it
 # assumes your terminal is set to use UTF-8
 if (grep /\P{ASCII}/ => @ARGV) { 
    @ARGV = map { decode("UTF-8", $_) } @ARGV;
 }
 
 $| = 1;   # comment out for performance

 END { close STDOUT } </pre></div>
<div class="slide">
<h1>Unicode Template: Set Traps

</h1><p>This avoids compile‐time 🐜  “bugs” in the pragma:

</p><pre> # XXX: use warnings FATAL => "all";
 
 local $SIG{__DIE__} = sub {
     confess "Uncaught exception: @_" unless $^S;
 };
 
 local $SIG{__WARN__} = sub {
     if ($^S) { cluck   "Trapped warning: @_" } 
     else     { confess "Deadly warning: @_"  }
 }; </pre></div>
<div class="slide">
<h1>Unicode Template: Filters

</h1><p>I use this on normal CLI ﬁlters:

</p><pre> if (@ARGV == 0 &amp;&amp; -t STDIN &amp;&amp; -t STDERR) {
    print STDERR "$0: reading input from tty, type ^D for EOF...\n";
 }

 while (&lt;>)  {
     chomp;
     $_ = NFD($_);
     ...
 } continue {
     say NFC($_);
 }
 
 __END__
 𝖍𝖎𝖈 𝖏𝖆𝖈𝖊𝖓𝖙 𝖉𝖆𝖙𝖆 𝖚𝖓𝖎𝖈𝖔𝖉𝖎𝖈𝖆 </pre></div>
<div class="slide">
<h1>🐪  Runtime Environment

</h1><ul><li level="1">The only 🐪‐related envariable I normally run with is
<code>PERL_UNICODE</code>, which I have set to <code>"SA"</code>. That’s equivalent to
running with the <code>-CSA</code> command‐line option.  Possible values are

<ul><li level="1"><code><b>0</b></code>    = turn oﬀ all ﬂags (that’s a DIGIT ZERO)

</li><li level="1"><code><b>I</b></code>    = STDIN is assumed to be in UTF‐8

</li><li level="1"><code><b>O</b></code>    = STDOUT will be in UTF‐8

</li><li level="1"><code><b>E</b></code>    = STDERR will be in UTF‐8

</li><li level="1"><code><b>S</b></code>    = <code><b>I</b></code> + <code><b>O</b></code> + <code><b>E</b></code>

</li><li level="1"><code><b>i</b></code>    = UTF‐8 is the default PerlIO layer for input streams

</li><li level="1"><code><b>o</b></code>    = UTF‐8 is the default PerlIO layer for output streams

</li><li level="1"><code><b>D</b></code>    = <code><b>i</b></code> + <code><b>o</b></code>

</li><li level="1"><code><b>A</b></code>    = the <code>@ARGV</code> elements are expected to be strings
encoded in UTF‐8

</li><li level="1"><code><b>L</b></code>    = makes <code><b>"IOEioA"</b></code> conditional on the locale
environment variables (<code>LC_ALL</code>, <code>LC_TYPE</code>, and <code>LANG</code>, in order of
decreasing precedence) — if the variables indicate UTF‐8, then the
selected <code><b>"IOEioA"</b></code> are in eﬀect.

</li></ul></li></ul></div>
<div class="slide">
<h1>🐪  Unicode Laundry List

</h1><ul><li level="1">That was the <i>easy</i> stuﬀ, but you’ve got to get it out of the way
before you can go on.

</li><li level="1">Now we’ll do the <i>real</i> work.

</li></ul></div>
<div class="slide">
<h1>🐜  Ixnay on the Ugbay Already! 🐜

</h1><ul><li level="1">🐪 used to have something called <b>“<i>The</i> Unicode Bug”</b> 🐜 .

</li><li level="1">Essentially, it caused code points in the range 128–255 to be
treated as binary, not text.

</li><li level="1">If you follow my instructions above, you should no longer be
aﬀected by it.

</li><li level="1">The critical ﬁx that makes it all possible is

<pre> use feature "unicode_strings"; </pre></li><li level="1">This feature was ﬁrst introduced in v5.12, but didn’t come 
up to full functionality until v5.14.

</li></ul></div>
<div class="slide">
<h1>Core Pragmas

</h1><ul><li level="1">Key core pragmas for Unicode are:

<ul><li level="1"><code>v5.14</code>

</li><li level="1"><code>utf8</code>

</li><li level="1"><code>feature</code>

</li><li level="1"><code>charnames</code>

</li><li level="1"><code>open</code>

</li><li level="1"><code>re "/<i>flags</i>"</code>

</li><li level="1"><code>encoding::warnings</code>

</li></ul></li><li level="1">Probably best to stay clear of these, though:

<ul><li level="1"><code>bytes</code>

</li><li level="1"><code>encoding</code>

</li><li level="1"><code>locale</code>

</li></ul></div>
<div class="slide">
<h1>Program Literals

</h1><p>Specify Unicode literals any of these ways:

</p><ol><li level="1"><p>As literal UTF‐8 under the recommended <code>utf8</code> pragma, allowing you to
write <code>"à contre-cœur"</code>, <code>"Ångström"</code>, or  <code>"👪 💗 🐪"</code> directly.

</p></li><li level="1"><p>As wicked “magic numbers” like <code>chr(0x1F4A9)</code>, <code>"\x{2639}"</code>, or <code>"\N{U+A0}"</code>.

</p></li><li level="1"><p>Using the <code>charnames</code> pragma and the <code>\N{<i>CHARNAME</i>}</code>
construct, strings like <code>"\N{LATIN SMALL LETTER A WITH GRAVE} 
contre-c\N{LATIN SMALL LIGATURE OE}ur"</code>, <code>"A\N{COMBINING RING
ABOVE}ngstro\N{COMBINING DIAERESIS}m"</code>, and <code>"\N{FAMILY} 
\N{GROWING HEART} \N{DROMEDARY CAMEL}"</code>.

</p></li></ol></div>
<div class="slide">
<h1>The <i>charnames</i> Pragma

</h1><ul><li level="1">Works on any interpolated string, including regexes.

</li><li level="1">Must be available at compile‐time.

</li><li level="1"><b>⚠ </b> Diﬀerent scopes can have diﬀerent name bindings. 

</li><li level="1">Import any combination of <code>:full</code>, 
<code>:short</code>, 
<code><i>SCRIPTNAME</i></code>,
or
<code>:alias</code>.

</li><li level="1">Also provides several functions (not for import):

<ul><li level="1"><code>charnames::string_vianame(<i>name</i>)</code> for runtime lookup of either
a character name or a named character sequence, returning its string
representation

</li><li level="1"><code>charnames::vianame(<i>name</i>)</code> for runtime lookup of a character
name (but <i>not</i> a named character sequence) to get its ordinal value
(code point)

</li><li level="1"><code>charnames::viacode(<i>code</i>)</code> for runtime lookup of a code point
to get its Unicode name.

</li></ul></li></ul></div>
<div class="slide">
<h1>Basic <i>charnames</i> Examples

</h1><ul><li level="1">Using full or short character names

<pre> use charnames ":full";
 print "\N{GREEK CAPITAL LETTER DELTA} is delta.\n";
    # Δ is delta.

 use charnames ':short';
 print "\N{greek:Delta} is an upper-case delta.\n";
    # Δ is an upper-case delta. </pre></li><li level="1">By script name

<pre>  use charnames qw(cyrillic greek);
  print "Sigmata are \N{Sigma}, \N{sigma}, and \N{final sigma}.\n";
    # Sigmata are Σ, σ, and ς.
  print "\N{Be} and \N{be} are Cyrillic B's.\n";
    # Б and б are Cyrillic B's. </pre></li></ul></div>
<div class="slide">
<h1>Custom <i>charnames</i> Examples

</h1><ul><li level="1">Customization via <code>:alias</code> and a hash:

<pre> use charnames ":full", ":alias" => {
     e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
     E_ACUTE => "LATIN CAPITAL LETTER E WITH ACUTE",
 };
 print "I'll have the \N{e_ACUTE}touff\N{e_ACUTE}e.\n";
    # I'll have the étouffée. </pre></li><li level="1">Customization via <code>:alias</code> and a string looks for a corresponding
ﬁle to require from <code>unicore/</code>, which must be a subdirectory under your
<code>@INC</code> path. For example, <code>:<b>html</b></code> would look for a ﬁle named
<code>unicore/<b>html</b>_alias.pl</code>.

<pre> use charnames ":alias" => ":html";
 print "\N{frac14} and \N{frac12} are \N{frac34}.\n";
    # ¼ and ½ are ¾. </pre></li></ul></div>
<div class="slide">
<h1>Core Modules

</h1><p>Key core modules for Unicode are:

</p><ul><li level="1"><code>Encode</code>

</li><li level="1"><code>Unicode::Normalize</code>

</li><li level="1"><code>Unicode::Collate</code>

</li><li level="1"><code>Unicode::Collate::Locale</code>

</li><li level="1"><code>Unicode::UCD</code>

</li><li level="1"><code>DBM_Filter::utf8</code>

</li></ul></div>
<div class="slide">
<h1>The <i>Encode</i> module

</h1></li><li level="1">The <code>Encode</code> module is most often used implicitly: it’s
loaded automatically whenever you pass an <code>:encoding(<i>ENC</i>)</code> 
argument to <code>binmode</code> or to <code>open</code>.

<pre> binmode(STDIN,       ":encoding(cp1252)")
               || die "can't binmode STDIN: $!";

 open(OUTPUT, "> :raw :encoding(UTF-16LE) :crlf", $filename) 
               || die "can't open $filename: $!";

 print OUTPUT while &lt;STDIN>;

 close(OUTPUT) || die "couldn't close $filename: $!";
 close(STDIN)  || die "couldn't close STDIN: $!"; </pre></div>
<div class="slide">
<h1>The <i>Encode</i> module <i>(cont¹…)</i>

</h1><ul><li level="1">The <code>Encode</code> module provides functions for when you need to
manually decode incoming data and to manually encode outgoing data.

</li><li level="1">The functions I most often use from it are <code>encode</code>, <code>decode</code>,
and <code>find_encoding</code>.

<pre> use Encode qw&lt; find_encoding >;
 for my $alias (qw&lt; utf8 UTF-8 utf16le >) {
     my $obj = find_encoding($alias);
     my $name = $obj ? $obj->name() : "UNKNOWN";
     printf "%-8s is really %s.\n", $alias, $name;
 } 

 # utf8     is really utf8.
 # UTF-8    is really utf-8-strict.
 # utf16le  is really UTF-16LE. </pre></li><li level="1">Try running my <i>byte2uni</i> tool like this for a blast from the past:

<pre> % byte2uni -a -e nextstep | less </pre></li></ul></div>
<div class="slide">
<h1>The <i>Encode</i> module <i>(cont²…)</i>


</h1><p>The MacRoman encoding is a bit weird:

</p><pre> use charnames qw&lt; :full >;
 use Encode (
     "decode",   # $unicode = decode("scheme", $bytes);
     "encode",   # $bytes   = encode("scheme", $unicode);
 );

 my $permil = "\N{PER MILLE SIGN}";
 printf "A permille %s is U+%vX in Unicode", $permil, $permil;

 my $bytes = encode("macroman", $permil);
 printf " but is 0x%vX in Macroman\n", $bytes;

    # A permille ‰ is U+2030 in Unicode but is 0xE4 in Macroman </pre></div>
<div class="slide">
<h1>The <i>Encode</i> module <i>(cont³…)</i>

</h1><p>The MacRoman encoding is <i>still</i> a bit weird:

</p><pre> use charnames qw&lt; :full >;
 use Encode (
     "decode",   # $unicode = decode("scheme", $bytes);
     "encode",   # $bytes   = encode("scheme", $unicode);
 );

 my $byte = chr(0x8E);
 my $char = decode("macroman", $byte);

 printf "An %vX in MacRoman is %vX in Unicode\n", $byte, $char;
 printf "Which is really a %s\n", charnames::viacode(ord $char);

    # An 8E in MacRoman is E9 in Unicode
    # Which is really a LATIN SMALL LETTER E WITH ACUTE </pre></div>
<div class="slide">
<h1>The <i>Unicode::Normalize</i> module

</h1><ul><li level="1">Because equivalent grapheme clusters can be written multiple ways,
you almost always want to normalize your data using functions from the
standard <code>Unicode::Normalize</code> module.

</li><li level="1">That’s why my standard template said:

<pre> while (&lt;>)  {
     chomp;
     $_ = NFD($_);
     ...
 } continue {
     say NFC($_);
 } </pre></li></ul></div>
<div class="slide">
<h1>Canonical Conundra

</h1><p>Just as one example, consider all these variants of a Latin small letter
<i>o</i> with tilde:

</p><!--

use v5.14;
use Unicode::Normalize;
my @s = (
    "\x{F5}",
    "o\x{303}",
    "\x{22D}",
    "\x{F5}\x{304}",
    "o\x{303}\x{304}",
    "o\x{304}\x{303}",
    "\x{14D}\x{303}",
);
my $count = 1;
for my $s (@s) {
    print $count++, " ";
    print "NFD" if $s eq NFD($s);
    print "NFC" if $s eq NFC($s);
    print "\n";
} 

1 NFC
2 NFD
3 NFC
4 
5 NFD
6 NFD
7 NFC

-->

<table width="100%" border=1>

<tr>
<th>N</th>
<th>Glyph</th>
<th>NFC?</th>
<th>NFD?</th>
<th>🐪🐪🐪🐪🐪</th>
<th>Code Points</th>
</tr>

<tr>
    <td>1</td>
    <td align=center><b><font face="Times New Roman">õ</font></b></td>
    <td align=center>✓</td>
    <td align=center>─</td>
    <td><code>"\x{F5}"</code></td>
    <td><code><font size="-2">LATIN SMALL LETTER O WITH TILDE</font></code></td>
</tr>

<tr>
    <td>2</td>
    <td align=center><b><font face="Times New Roman">õ</font></b></td>
    <td align=center>─</td>
    <td align=center>✓</td>
    <td><code>"o\x{303}"</code></td>
    <td><code><font size="-2">LATIN SMALL LETTER O, COMBINING TILDE</font></code></td>
</tr>

<tr>
    <td>3</td>
    <td align=center><b><font face="Times New Roman">ȭ</font></b> </td>
    <td align=center>✓</td>
    <td align=center>─</td>
    <td><code>"\x{22D}"</code></td>
    <td><code><font size="-2">LATIN SMALL LETTER O WITH TILDE AND MACRON</font></code></td>
</tr>

<tr>
    <td>4</td>
    <td align=center><b><font face="Times New Roman">ȭ</font></b></td>
    <td align=center>─</td>
    <td align=center>─</td>
    <td><code>"\x{F5}\x{304}"</code></td>
    <td><code><font size="-2">LATIN SMALL LETTER O WITH TILDE, COMBINING MACRON</font></code></td>
</tr>

<tr>
    <td>5</td>
    <td align=center><b><font face="Times New Roman">ȭ</font></b></td>
    <td align=center>─</td>
    <td align=center>✓</td>
    <td><code>"o\x{303}\x{304}"</code></td>
    <td><code><font size="-2">LATIN SMALL LETTER O, COMBINING TILDE, COMBINING MACRON</font></code></td>
</tr>

<tr>
    <td>6</td>
    <td align=center><b><font face="Times New Roman">ō̃</font></b></td>
    <td align=center>─</td>
    <td align=center>✓</td>
    <td><code>"o\x{304}\x{303}"</code></td>
    <td><code><font size="-2">LATIN SMALL LETTER O, COMBINING MACRON, COMBINING TILDE</font></code></td>
</tr>

<tr>
    <td>7</td>
    <td align=center><b><font face="Times New Roman">ō̃</font></b></td>
    <td align=center>✓</td>
    <td align=center>─</td>
    <td><code>"\x{14D}\x{303}"</code></td>
    <td><code><font size="-2">LATIN SMALL LETTER O WITH MACRON, COMBINING TILDE</font></code></td>
</tr>

</table>

</div>
<div class="slide">
<h1>Oh shucks...

</h1><ul><li level="1">Assuming you enforce NFD on input, then 1 shows up as 2, both of 3
<i>&</i> 4 show up as 5, and 7 shows up as 6.

</li><li level="1">Assuming you enforce NFC on output, then 2 shows up as 1, both of
4 <i>&</i> 5 show up  as 3, and 6 shows up as 7.

</li><li level="1">That means that by normalizing to <i>either</i> NFD <i>or</i> NFC, you can
do a simple <code>eq</code> to get 1 <i>&</i> 2, 3–5, and 6 <i>&</i> 7 to each
respectively test equal to one another.

</li><li level="1">Notice, however, that that’s three diﬀerent sets.

</li><li level="1">Number 4 is in <i>neither</i> NFC <i>nor</i> NFD.  These things happen.
It gets worse.  Normalize.  Always.  Please.

</li></ul></div>
<div class="slide">
<h1>... and more shucks!

</h1><p>In a regex, all 7 of those will be completely matched by <code>\X</code>, an
extended grapheme cluster. Yes, but now what? 😭 I’m afraid this is
where it stops being easy.  NFD is assumed <i>and required</i> for the
following to work:

</p><ul><li level="1"><code>/^o/</code> reports that all 7 start with an <i>o</i>.

</li><li level="1"><code>/^o\x{COMBINING TILDE}/</code> reports that 1–5 start with an <i>o</i> and
a tilde, but that misses 6 <i>&</i> 7.

</li><li level="1">You’d need <code>/^o\pM*?\x{COMBINING TILDE}/</code> to get all 7 matching.

</li><li level="1">This is still just a stab, with various issues still unresolved
(like using <code>\p{Grapheme_Extend}</code> instead of <code>\pM</code> — and, were there
any, using <code>\p{Grapheme_Base}</code> instead of <code>\PM</code>):

<pre> $o_tilde_rx = qr{ o \pM *? \x{COMBINING TILDE} \pM* }x; </pre></li></ul></div>
<div class="slide">
<h1>👽 Filesystems Hate You

</h1><ul><li level="1">You are going to have ﬁlesystem issues, especially on 👽
ﬁlesystems.

</li><li level="1">Some ﬁlesystems silently enforce a conversion to NFC;
others silently enforce a conversion to NFD. And others do
something else still.

</li><li level="1">Some even ignore the matter altogether, which leads to even
greater problems.

</li><li level="1">So you really do have to do your own NFC/NFD handling to keep
sane. I think.  Maybe.

</li></ul></div>
<div class="slide">
<h1>The <i>Unicode::Collate</i> module

</h1><ul><li level="1">Partly for reasons just shown, string comparisons on Unicode 
are pretty much always the wrong way to go.  

</li><li level="1">That includes <code>eq</code>, <code>ne</code>, <code>le</code>, <code>gt</code>, <code>cmp</code>, 
<code>sort</code>, <i>&c &c</i>. 😓 

</li><li level="1">Enter the standard <code>Unicode::Collate</code> module.  It’s super‐fancy,
so I’ll just show the simplest approaches here.

</li><li level="1">You can get a taste for how it works by playing around with my <b><i>ucsort</i></b> utility.

</li></ul></div>
<div class="slide">
<h1>Replacing <i>sort</i>

</h1><ul><li level="1">Whenever you’ve an array of <i>text strings</i> to sort, as in 
<code>@a = sort @b</code>, just swap that code out for this 
and all will be well:

<pre> use Unicode::Collate;
 @sorted = Unicode::Collate::->new->sort(@unsorted); </pre></li><li level="1">There’s also a standard <code>Unicode::Collate::Locale</code> module 
for national sorts.

<pre> use Unicode::Collate::Locale;

 state $coll = new Unicode::Collate::Locale::
                   locale => "fr",
       # lots of other parameters possible here
               ;

 my @bons_mots = $coll->sort(our @mots); </pre></li></ul></div>
<div class="slide">
<h1>Replacing <i>eq</i>

</h1><ul><li level="1">Most real‐world sorts are more complex than those.

<pre> @srecs = sort {
     $b->{AGE}   &lt;=>  $b->{AGE}
                 ||
     $a->{NAME}  cmp  $b->{NAME}
 } @recs; </pre></li><li level="1">Enter the <code>getSortKey</code> method:

<pre> my $collator = Unicode::Collate::->new();
 for my $rec (@recs) {
     $rec->{NAME_key} = $collator->getSortKey($rec->{NAME});
 } 
 @srecs = sort {
     $b->{AGE}       &lt;=>  $b->{AGE}
                     ||
     $a->{NAME_key}  cmp  $b->{NAME_key}
 } @recs; </pre></li></ul></div>
<div class="slide">
<h1>Program Options to <i>ucsort</i> 

</h1><p>These are its literal <code>Getopt:::Long</code> arguments:

</p><pre>  # collator constructor options
    --backwards-levels=i
    --collation-level|level|l=i
    --katakana-before-hiragana
    --normalization|n=s
    --override-CJK=s
    --override-Hangul=s
    --preprocess|P=s
    --upper-before-lower|u
    --variable=s

  # program specific options
    --case-insensitive|insensitive|i
    --input-encoding|e=s
    --locale|L=s
    --paragraph|p
    --reverse-fields|last
    --reverse-output|r
    --right-to-left|reverse-input </pre></div>
<div class="slide">
<h1>CPAN Modules

</h1><p>CPAN modules for handling Unicode include:

</p><ul><li level="1"><code>Unicode::LineBreak</code>, which includes <code>Unicode::GCString</code>. These
respectively solve “the <code>format</code> problem” and “the <code>printf</code> problem”.

</li><li level="1"><code>Unicode::Casing</code> for things like 
<code>lc</code> <i>ΣΤΙΓΜΑΣ</i> ⇒  <i>στιγμας</i> in Greek, or <code>uc</code> <i>i</i> ⇒  <i>İ</i> in the Turkic languages.

</li><li level="1"><code>Unicode::Unihan</code>, and
if you liked the last one, you might want to look into
<code>Lingua::JA::Romanize::Japanese</code>,
<code>Lingua::KO::Hangul::Util</code>,
<code>Lingua::KO::Romanize::Hangul</code>,
<code>Lingua::ZH::Romanize::Pinyin</code>, <i>&c</i>.

</li><li level="1"><code>Unicode::Stringprep</code>

</li></ul></div>
<div class="slide">
<h1>No POSIX Locales, <i>por favor</i>

</h1><ul><li level="1">Please don't (try to) use POSIX locales’ collation.  Use Unicode’s.

</li><li level="1">Normalization won’t always help you enough.  For example, you
can’t use it to get <i>o</i>, <i>õ</i>, and <i>ø</i> to look the same, because
<code>LATIN SMALL LETTER O WITH STROKE</code> has no decomposition to something
with an <i>o</i> in it.

</li><li level="1">When comparing whether letters are the same, <code>Unicode::Collate</code>
<i>does</i> count <i>o</i>, <i>õ</i>, and <i>ø</i> as the same letter — normally.  Not
in Swedish or Hungarian, though.

</li><li level="1">Similarly with <i>d</i> and <i>ð</i> — you can’t decompose <code>LATIN SMALL
LETTER ETH</code> to anything with a <i>d</i> in it, but the UCA treats them as
the same letter.  <i>Er</i>, except in Icelandic (the <code>"is"</code> locale), where
<i>d</i> and <i>ð</i> are now diﬀerent letters in their own right.

</div>
<div class="slide">
<h1>Unicode Locales

</h1><ul><li level="1">What about <i>ae</i> <i>&</i> <i>æ</i> <code>\x{E6}</code>, or <i>oe</i> <i>&</i> <i>œ</i> <code>\x{153}</code>?  Those aren’t
casefolds of each other as occurs with <i>ij</i> and <i>ĳ</i> <code>\x{133}</code>, 
and there’s no useful decomposition, either.  But <code>Unicode::Collate</code> <i>will</i> treat them
alike. 

</li><li level="1">Usually, that is. <i>However</i>, in the “German phonebook” locale, <b>now</b> <i>ae</i> and <i>æ</i>
are diﬀerent — but <i>ae</i> and <i>ä</i> 
(whether written <code>\x{E4}</code> or <code>a\x{308}</code>)
are the same.  No kidding.

</li><li level="1">Here’s how to do a locale compare: 

<pre> state $coll = new Unicode::Collate::Locale:: 
                locale => "de__phonebook", 
            ;

 if ($coll->eq($a, $b)) { ... } </pre></li><li level="1">Now what? It’s tough, I tell you.  
See my collation examples in my
<code>FixString.pm</code> module and my 
<i>es-sort</i>,
<i>núñez</i>, and 
<i>unilook</i> tools.

</li></ul></div>
<div class="slide">
<h1>Unicode Regex Gotchas

</h1><ul><li level="1">Code that uses <code>\p{Lu}</code> is almost as wrong as code that uses 
<code>[A-Za-z]</code>.  You need to use <code>\p{Upper}</code> instead, because
<code>\p{Lowercase}</code> (≡ <code>\p{Lower}</code>) <b><i>is diﬀerent</i></b> from 
<code>\p{Lowercase_Letter}</code> (≡ <code>\p{Ll}</code>) by 159 code points:

<pre> % unichars '\p{Lowercase}' '\P{Lowercase_Letter}' 
 % unichars '\p{Lower}'     '\P{Ll}'  # same but easier to type </pre></li><li level="1">Code that uses <code>[a-zA-Z]</code> is even worse.  And it can’t use <code>\pL</code>
or <code>\p{Letter}</code>; it needs to use <code>\p{Alphabetic}</code>. Not all alphabetics
are letters:

<pre> % unichars -a '\p{alphabetic}' '\P{Letter}' | wc -l # 1006 code points </pre></li><li level="1">If you are looking for 🐪 variables with <code>/[\$\@%]\w+/</code>, then you
have a problem (or two).  

<ul><li level="1">You need to look for <code>/[\$\@%]\p{IDS}\p{IDC}*/</code>

</li><li level="1">Even that isn’t thinking about the punctuation variables or package
variables.

</li></ul></li></ul></div>
<div class="slide">
<h1>Unicode Regex Gotchas <i>(cont¹…)</i>

</h1><ul><li level="1">If you are checking for whitespace, then you should choose between
<code>\h</code> and <code>\v</code>, depending.  And you should never use <code>\s</code> to mean all possible Unicode whitespace.

</li><li level="1">For historical reasons, <code>\s</code>
<b><i>does not mean</i></b> <code>[\h\v]</code>.  These both tell the same tale:

<pre> % unichars '\S' '[\v\h]' 
  ---- U+000B LINE TABULATION

 % unichars '\S' '\p{space}'   
  ---- U+000B LINE TABULATION </pre></div>
<div class="slide">
<h1>Unicode Regex Gotchas <i>(cont²…)</i>

</h1><ul><li level="1">If you are using <code>\n</code> for a line boundary, or even <code>\r\n</code>, then
you are doing it wrong.  

</li><li level="1">The Unicode linebreak sequence metacharacter is <code>\R</code>.  It means <code>(?:\r\n|\v)</code>.

<pre> % unichars '\R'
  ---- U+000A LINE FEED (LF)
  ---- U+000B LINE TABULATION
  ---- U+000C FORM FEED (FF)
  ---- U+000D CARRIAGE RETURN (CR)
  ---- U+0085 NEXT LINE (NEL)
  ---- U+2028 LINE SEPARATOR
  ---- U+2029 PARAGRAPH SEPARATOR </pre></li><li level="1">You <i>could</i> always canonicalize to linefeeds:

<pre> my $slurpy = `cat somefile`;    # pretend I didn’t do this :)
    $slurpy =~ s/\R/\n/g;        # convert Unicode linebreaks </pre></li></ul></div>
<div class="slide">
<h1>Unicode Antipatterns 💩

</h1><p>People
make millions of broken assumptions 
about Unicode. Until they understand these things, their  🐪 code
will be broken. Look for these <i><b>Unicode antipatterns</b></i>:

</p><ul><li level="1">Code that assumes it can open a text ﬁle without specifying the
encoding is broken.

</li><li level="1">Code that assumes the default encoding is some sort of native
platform encoding is broken.

</li><li level="1">Code that assumes web pages in Japanese or Chinese take up
less space in UTF‐16 than in UTF‐8 is wrong.

</li><li level="1">Code that assumes 🐪 uses UTF‐8 internally is wrong.

</li><li level="1">Code that assumes encoding errors will always raise an
exception is wrong.

</li><li level="1">Code that assumes 🐪 code points are limited to 0x10_FFFF is wrong.

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(cont¹…)</i>

</h1><ul><li level="1">Code that assumes you can set <code>$/</code> to something that will work
with any valid line separator is wrong. <code>\R</code> only works in patterns.

</li><li level="1">Code that assumes roundrip equality on casefolding, like
<code>lc(uc($s)) eq $s</code> or <code>uc(lc($s)) eq $s</code>, is completely borken and
worng.  Consider that the <code>uc("σ")</code> and <code>uc("ς")</code>  are both <code>"Σ"</code>,
but <code>lc("Σ")</code> cannot possibly return both of those.

</li><li level="1">Code that assumes every lowercase code point has a distinct
uppercase one, or vice versa, is broken. For example, <code>"ª"</code> is a
lowercase letter with no uppercase.   Kinda.

</li><li level="1">Whereas both <code>"ᵃ"</code> and <code>"ᴬ"</code> <i>are</i> <code>Cased</code> letters, they casemap
only to themselves. Both <i>are</i> <code>Lowercase</code>, and <code>Letter</code>s, but they are not
<code>Lowercase_Letter</code>s. 

</li><li level="1">Got that? They are <i>not</i> <code>\p{Lowercase_Letter}</code>, despite being
both <code>\p{Letter}</code>s and <code>\p{Lowercase}</code>.  They’re <code>\p{Modifier_Letter}</code>s, 
actually.  Honest.

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(cont²…)</i>

</h1><ul><li level="1">Code that assumes changing the case doesn’t change the length of
the string is broken.

<pre> % unichars -gas 'grep { length > 1 } lc, ucfirst, uc' </pre></li><li level="1">Code that assumes there are only two cases is broken. There’s also
titlecase.

<pre> % unichars -gas 'uc ne ucfirst' </pre></li><li level="1">Code that assumes only letters have <code>Case</code> is broken. 
Beyond just letters, it turns out that numbers, symbols, and even marks have case.

<pre> % unichars -gas '\PL' '\p{Cased}' </pre></li><li level="1">Code that assumes casemapping a <code>Cased</code> code point always gives a diﬀerent code point is broken.
This shows there are 1299 un–case‐changing cased code points:

<pre> % unichars -gas '\p{Cased}' '[^\p{CWL}\p{CWT}\p{CWU}]' </pre></li><li level="1">Code that assumes case is <i>never</i> locale‐dependent is broken, as is
code that assumes Unicode gives a ﬁckle ﬂying ﬁg about legacy POSIX locales.

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(cont³…)</i>

</h1><ul><li level="1">Code that uses something like <code>y/\000-\177/\200-\377/</code> is broken
and wrong.
Try <code>tr[\0-\x{10_FFFF}][\x{20_0000}-\x{30_FFFF}]</code> if you dare.

</li><li level="1">Code that assumes it can remove <code>Mark</code>s to get “ASCII”
letters is 

<a href="http://www.catb.org/jargon/html/E/evil-and-rude.html" target=_blank>
evil and rude</a>.

</li><li level="1">Code that assumes diacritics <code>\p{Diacritic}</code> and marks
<code>\p{Mark}</code> are the same thing is broken.

<pre> % unichars -gas '\p{mark}' '\P{DIACRITIC}'   # 1068 code points
 % unichars -gas '\P{MARK}' '\p{diacritic}'   #  209 code points </pre></li><li level="1">Code that assumes the general category <code>\p{GC=Dash_Punctuation}</code> covers as much as
the binary property <code>\p{Dash=Yes}</code> is broken.

</li><li level="1">Code that naïvely assumes dash, hyphens, and minuses are all the 
same thing as each other, or that there is only one of each, is 
broken and wrong.  

<pre> % unichars -gas '\p{Dash}' </pre></li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(cont⁴…)</i>

</h1><ul><li level="1">Code that assumes every code point takes up no more than one print
column is broken. 

</li><li level="1">Code that assumes all <code>\p{Mark}</code>
characters take up zero print columns is broken.

<pre> % unichars -gas '\pM' '\P{BC=NSM}' </pre></li><li level="1">Code that assumes characters which look alike <i>are</i> alike
is broken.

</li><li level="1">Code that assumes characters which do <i>not</i> look alike are
<i>not</i> alike is broken.

</li><li level="1">Code that assumes there is a limit to the number of code points in
a row that just one <code>\X</code> can match is wrong.

</li><li level="1">Code that assumes <code>\X</code> can never start with a <code>\p{Mark}</code>
character is wrong.

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(cont⁵…)</i>

</h1><ul><li level="1">Code that assumes <code>\X</code> can never hold two non‐<code>\p{Mark}</code>
characters is wrong.

</li><li level="1">Code that assumes it cannot use <code>"\x{FFFF}"</code> is wrong.

</li><li level="1">Code that assumes a non‐BMP code point requiring two UTF‐16
(surrogate) “code units” will encode to two separate UTF‐8 characters, one
per code unit, is wrong. It doesn’t: it encodes to a single code point.
<b>Or should.</b>

</li><li level="1">Code that transcodes from UTF‐16 or UTF‐32 with leading BOMs into
UTF‐8 is broken if it puts a BOM at the start of the resulting UTF‐8, because
it just changed the number of code points in the data!  <b>Wʀᴏɴɢ‼</b>

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(cont⁶…)</i>

</h1><ul><li level="1">Code that assumes the CESU‐8 is a valid UTF encoding is wrong.
Likewise, code that thinks encoding U+0000 as bytes <code>"\xC0\x80"</code> is UTF‐8 is
broken and wrong. 

</li><li level="1">Code that assumes characters like < always points to the
right and > always points to the left are wrong — because they in
fact do not.

<pre> % perl -Mcharnames=:full -E 'say "\N{RLE}", "12 &lt; 345 &lt; 6789"'
 6789 > 345 > 12
 % perl -Mcharnames=:full -E 'say "\N{RLO}", "12 &lt; 345 &lt; 6789"'
 9876 > 543 > 21 </pre></li><li level="1">Code that assumes if you ﬁrst output character <code>X</code> and then
character <code>Y</code>, that those will show up as <code>XY</code> is wrong. Sometimes
they don’t.

</li><li level="1"><b>Code that assumes ASCII is good enough for writing English
properly is stupid, shortsighted, illiterate, broken, evil, and wrong.</b>

</li><li level="1">I have stronger words for it, too.

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(cont⁷…)</i>

</h1><ul><li level="1">Code that assumes all <code>\p{Math}</code> code points are visible
characters is wrong.

</li><li level="1">Code that assumes <code>\w</code> contains only letters, digits, and
underscores is wrong — unless you use the <code>/a</code> modiﬁer or

<pre>    use re "/a"; </pre></li><li level="1">Code that assumes <code>^</code> and <code>~</code> are punctuation marks is
wrong.

</li><li level="1">Code that assumes <i>ë</i> has an umlaut character in it is wrong, thrice.

</li><li level="1">Code that believes symbols like <code>㏂</code>, <code>℉</code>, <code>㎨</code>,  <code>₨</code>, <i>&</i> <code>™</code> contain any letters in
them is wrong — except in NFKD:

<pre>  % unichars -gas '\pS' 'NFKD =~ /\p{Latin}/' | ucsort | less -r </pre></li><li level="1">Code that believes <code>\p{InLatin}</code> is the same as <code>\p{Latin}</code> is
heinously broken.

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(cont⁸…)</i>

</h1><ul><li level="1">Code that believes <code>\p{InLatin}</code> is almost ever useful is
almost certainly wrong.

</li><li level="1">Code that believes that, given <code>$FIRST_LETTER</code> as the ﬁrst letter
in some alphabet and <code>$LAST_LETTER</code> as the last letter in that same
alphabet, writing <code>[${FIRST_LETTER}-${LAST_LETTER}]</code> has any meaning
whatsoever is almost always complete broken and wrong and meaningless.

</li><li level="1">Code that believes someone’s name can only contain certain
characters is oﬀensive, broken, and wrong.

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(cont⁹…)</i>

</h1><ul><li level="1">Code that believes there’s some way to pretend textﬁle
encodings don’t exist is broken and dangerous. 

</li><li level="1">Code that converts unknown characters to <code>?</code> is broken, stupid,
braindead, and runs contrary to the standard recommendation, which says
<i>not to do that!</i> So don’t.

</li><li level="1">Code that believes it can reliably guess the encoding of an
unmarked textﬁle is guilty of a fatal mélange of hubris and naïveté that
only a lightning bolt from Zeus will ﬁx.

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(cont¹⁰...)</i>

</h1><ul><li level="1">Code that believes you can use 🐪 <code>printf</code> widths to pad and
justify Unicode data is broken and wrong. Use <code>Unicode::GCString</code> to count columns.

</li><li level="1">Code that believes once you successfully create a ﬁle by a given
name, that when you run <code>ls</code> or <code>readdir</code> on its enclosing directory,
you’ll actually ﬁnd that ﬁle with the name you created it under is
buggy, broken, and wrong. Stop being surprised by this!

</li><li level="1">Code that believes UTF‐16 is a ﬁxed‐width encoding is stupid,
broken, and wrong. 

</li><li level="1">Code that treats code points from one plane one whit diﬀerently
than those from any other plane is <i>ipso facto</i> broken and wrong. 

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(cont¹¹...)</i>

</h1><ul><li level="1">Code that believes that stuﬀ like <code>/s/i</code> can match only <code>"S"</code> or
<code>"s"</code> is broken and wrong. You’d be surprised!

</li><li level="1">Code that uses <code>\PM\pM</code> to ﬁnd grapheme clusters instead of using
<code>\X</code> is broken and wrong.

</li></ul></div>
<div class="slide">
<h1>Appendix 1: Font suggestions

</h1><a name=appendix1_fonts>
</a>

<ul><li>
I recommend 
two free fonts from George
Douros at
<A HREF="http://users.teilar.gr/~g1951d/">
users.teilar.gr/~g1951d/</a> 
known to work with this presentation: his <i>Al&#64257;os</i> font for regular
text, and his <i>Symbola</i> font for fancy emoji.
If any of these don&#8217;t look right to you, you probably need to 
supplement your system fonts:
<ul>

<li>Ligatures: 
    <font face="'Arno Pro', Alfios,  Pali, Serif">
        &#64257; &#64259; &#64256; &#64260; &#64258; &#946; &#7838; &#64261;  &#64262; 
    </font>

<li>Math letters: 
    <font face="Symbola, Serif">
        &#119964; &#119967; &#120069; &#120078; &#120124; &#120125; 
    </font>

<li>Gothic <i>&</i> Deseret: 
    <font face="Symbola, Serif">
&#66360;&#66364;&#66365;&#66370;, &#66580;&#66607;&#66629;&#66600;&#66633;&#66607;&#66619;
    </font>

<li>Symbols: 
    <font face="Symbola, Sans">
        &#10004; &#9989; &#128042; &#128214; &#128706; &#128013; 
    </font>

<li>Emotica: 
    <font face="Symbola, Sans">
        &#128519; &#128520; &#128521; &#128552; &#128557; &#128561; 
    </font>

<li>Upside&#8208;down:
    <font size=2 face="Monaco, Mono">
        &#161;p&#592;&#601;&#613; &#633;no&#654; uo &#387;u&#7433;pu&#592;&#647;s &#654;q s&#7433;&#613;&#647; p&#592;&#601;&#7450;
    </font>

<li>Combining characters: 


    <font face="Monaco, 'Everson Mono', Mono">
&#9676;&#770;,&#9676;&#771;,&#9676;&#8414;,&#9676;&#818;,&#9676;&#65024;,&#9676;&#821;,&#9676;&#823;
    </font>

</ul>
<li>The last line with combining characters is especially hard to get to
look right.  You may &#64257;nd that the shareware font <i>Everson Mono</i>
works when all else fails.

</ul>

</div>
<div class="slide">
<h1>Appendix 2: Tools

</h1><ul>
<li>
I wrote a huge bucketful of tools to make your life with Unicode not just easier, but more fun.
<li>These are available in 
the <a href="http://search.cpan.org/perldoc?Unicode::Tussle" target=_blank>Unicode::Tussle</a> bundle from CPAN,
where they come with <a href="http://search.cpan.org/perldoc?Unicode::Tussle" target=_blank>documentation</a>,
or you can get them individually 
from <a href="http://training.perl.com/scripts/" target=_blank>training.perl.com/scripts</a> if you&#8217;d prefer.

<li>
Thanks very much to <i>brian d foy</i> for putting that CPAN bundle together for me.
</ul>

</div>
<div class="slide">
<h1>Contact Information

</h1><ul>
<li>
I’m Tom Christiansen.  You can reach me at <A HREF="mailto:tchrist@perl.com">tchrist@perl.com</a>.
<li>
All three talks, as well as these instructions, are available from 
<a  href="http://training.perl.com/OSCON2011/index.html">
training.perl.com/OSCON2011</a>.
</ul>

</div>
<div class="slide">
<h1>YANETUT

</h1><p>文字化け 
𝀬
𝀳
𝀵
𝀷
𝀺
𝁁
𝁩
𝁭
𝁲
𝄁
𝄃
𝄈
𝄍
𝄏
𝄒
𝄔
𝄗
𝄙
𝄬
𝄯
𝄱
𝄵
𝄹
𝄻
𝅀
𝅘𝅥𝅲
𝅫
𝆄
𝆒
𝆕
𝆗
𝆚
𝆶
𝆹𝅥
𝆺𝅥𝅯
🀀
🀄
🀈
🀋
🀍
🀐
🀒
🀕
🀚
🀞
🀠
🀣
🀦
🀨
🀫
🂩
🂬
🂮
🂱
🂵
🂺
🂼
🃁
🃃
🃆
🃈
🃍
🃓
🃕
🃘
🃚
🃝
🃟
🌀
🌁
🌂
🌃
🌄
🌅
🌆
🌇
🌈
🌉
🌊
🌋
🌌
🌍
🌎
🌏
🌐
🌑
🌒
🌓
🌔
🌕
🌖
🌗
🌘
🌙
🌚
🌛
🌜
🌝
🌞
🌟
🌠
🌰
🌱
🌲
🌳
🌴
🌵
🌷
🌸
🌹
🌺
🌻
🌼
🌽
🌾
🌿
🍀
🍁
🍂
🍃
🍄
🍅
🍆
🍇
🍈
🍉
🍊
🍋
🍌
🍍
🍎
🍏
🍐
🍑
🍒
🍓
🍔
🍕
🍖
🍗
🍘
🍙
🍚
🍛
🍜
🍝
🍞
🍟
🍠
🍡
🍢
🍣
🍤
🍥
🍦
🍧
🍨
🍩
🍪
🍫
🍬
🍭
🍮
🍯
🍰
🍱
🍲
🍳
🍴
🍵
🍶
🍷
🍸
🍹
🍺
🍻
🍼
🎀
🎁
🎂
🎃
🎄
🎅
🎆
🎇
🎈
🎉
🎊
🎋
🎌
🎍
🎎
🎏
🎐
🎑
🎒
🎓
🎠
🎡
🎢
🎣
🎤
🎥
🎦
🎧
🎨
🎩
🎪
🎫
🎬
🎭
🎮
🎯
🎰
🎱
🎲
🎳
🎴
🎵
🎶
🎷
🎸
🎹
🎺
🎻
🎼
🎽
🎾
🎿
🏀
🏁
🏂
🏃
🏄
🏆
🏇
🏈
🏉
🏊
🏠
🏡
🏢
🏣
🏤
🏥
🏦
🏧
🏨
🏩
🏪
🏫
🏬
🏭
🏮
🏯
🏰
🐀
🐁
🐂
🐃
🐄
🐅
🐆
🐇
🐈
🐉
🐊
🐋
🐌
🐍
🐎
🐏
🐐
🐑
🐒
🐓
🐔
🐕
🐖
🐗
🐘
🐙
🐚
🐛
🐜
🐝
🐞
🐟
🐠
🐡
🐢
🐣
🐤
🐥
🐦
🐧
🐨
🐩
🐪
🐫
🐬
🐭
🐮
🐯
🐰
🐱
🐲
🐳
🐴
🐵
🐶
🐷
🐸
🐹
🐺
🐻
🐼
🐽
🐾
👀
👂
👃
👄
👅
👆
👇
👈
👉
👊
👋
👌
👍
👎
👏
👐
👑
👒
👓
👔
👕
👖
👗
👘
👙
👚
👛
👜
👝
👞
👟
👠
👡
👢
👣
👤
👥
👦
👧
👨
👩
👪
👫
👬
👭
👮
👯
👰
👱
👲
👳
👴
👵
👶
👷
👸
👹
👺
👻
👼
👽
👾
👿
💀
💁
💂
💃
💄
💅
💆
💇
💈
💉
💊
💋
💌
💍
💎
💏
💐
💑
💒
💓
💔
💕
💖
💗
💘
💙
💚
💛
💜
💝
💞
💟
💠
💡
💢
💣
💤
💥
💦
💧
💨
💩
💪
💫
💬
💭
💮
💯
💰
💱
💲
💳
💴
💵
💶
💷
💸
💹
💺
💻
💼
💽
💾
💿
📀
📁
📂
📃
📄
📅
📆
📇
📈
📉
📊
📋
📌
📍
📎
📏
📐
📑
📒
📓
📔
📕
📖
📗
📘
📙
📚
📛
📜
📝
📞
📟
📠
📡
📢
📣
📤
📥
📦
📧
📨
📩
📪
📫
📬
📭
📮
📯
📰
📱
📲
📳
📴
📵
📶
📷
📹
📺
📻
📼
🔀
🔁
🔂
🔃
🔄
🔅
🔆
🔇
🔈
🔉
🔊
🔋
🔌
🔍
🔎
🔏
🔐
🔑
🔒
🔓
🔔
🔕
🔖
🔗
🔘
🔙
🔚
🔛
🔜
🔝
🔞
🔟
🔠
🔡
🔢
🔣
🔤
🔥
🔦
🔧
🔨
🔩
🔪
🔫
🔬
🔭
🔮
🔯
🔰
🔱
🔲
🔳
🔴
🔵
🔶
🔷
🔸
🔹
🔺
🔻
🔼
🔽
🕐
🕑
🕒
🕓
🕔
🕕
🕖
🕗
🕘
🕙
🕚
🕛
🕜
🕝
🕞
🕟
🕠
🕡
🕢
🕣
🕤
🕥
🕦
🕧
🗻
🗼
🗽
🗾
🗿
😁
😂
😃
😄
😅
😆
😇
😈
😉
😊
😋
😌
😍
😎
😏
😐
😒
😓
😔
😖
😘
😚
😜
😝
😞
😠
😡
😢
😣
😤
😥
😨
😩
😪
😫
😭
😰
😱
😲
😳
😵
😶
😷
😸
😹
😺
😻
😼
😽
😾
😿
🙀
🙅
🙆
🙊
🙍
🙏
🚁
🚃
🚇
🚈
🚌
🚏
🚑
🚔
🚖
🚙
🚞
🚢
🚤
🚧
🚪
🚬
🚯
🚳
🚸
🜂
🜃
🜇
🜈
🜐
🜓
🜕
🜘
🜝
🜡
🜤
🜦
🜩
🜫
🜮
🜲
🜳
🜷
🜺
🜼
🜿
🝁
🝈
🝌
🝍
🝐
🝒
🝗
🝟
🝢
🝩
🝮
🝰
🝳
〠
ꝣ
𐌴
𐌶
𐌹
𐌻
𐌾
𐍃
𐍄
𐍈
𐍊
𒂊
𒂭
𒂱
𒃔
𒇉
𒋧
𒋼
𒌣

</p></li></ul></li></ul></li></ul></li></div></body></html>




<!--
     FILE ARCHIVED ON 11:41:28 Nov 4, 2012 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 0:28:30 Nov 25, 2015.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
