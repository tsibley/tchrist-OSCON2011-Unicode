<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>




<title>Perl Unicode Essentials</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="pod2s5 0.08" />
<meta name="generator" content="S5" />
<meta name="version" content="S5 1.1 hacked by tchrist" />
<meta name="presdate" content="Tuesday, 28 July 2011" />
<meta name="author" content="Tom Christiansen" />
<meta name="company" content="&nbsp;" />
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<link rel="stylesheet" href="ui/default/slides.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/default/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/default/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/default/opera.css" type="text/css" media="projection" id="operaFix" />

<!-- embedded styles -->
<style type="text/css" media="all">
.imgcon {width: 525px; margin: 0 auto; padding: 0; text-align: center;}
#anim {width: 270px; height: 320px; position: relative; margin-top: 0.5em;}
#anim img {position: absolute; top: 42px; left: 24px;}
img#me01 {top: 0; left: 0;}
img#me02 {left: 23px;}
img#me04 {top: 44px;}
img#me05 {top: 43px;left: 36px;}
</style>
<!-- S5 JS -->
<script src="ui/default/slides.js" type="text/javascript"></script>
<!--
   tom AT cpan.org:
   this will not work, it's not contained
   in the downloadable S5
   <script src="/mint/?js" type="text/javascript"></script></head>
-->
</head><body>




<div class="layout">

<div id="controls"></div>
<div id="currentSlide"></div>
<div id="header"></div>
<div id="footer">
<h1>OSCON &#8226; Tuesday, 28 July 2011</h1>
<h2>Perl Unicode Essentials</h2></div>
</div><div class="slide">
<h1>ğŸª Perl Unicode Essentials

</h1><blockquote>

<p align=center> <font size="6">Growing explosively over the last decade, most text today is
now in Unicode, with some corpora reaching 100% Unicode.  This tutorial
shows Perl programmers how to write scripts to handle Unicode data
reliably.  </font></p>

</blockquote>


<p align=left>

<h2 align=center>
    <font size="7">
Tom Christiansen<BR>
    </font>
    <font size="6">
&lt;tchrist@perl.com&gt;
    </font>
</h2>

<p align=center>
    <code>
    <font face="Monaco, mono" size="5">
        ğŸ˜ˆ  Â¡Æ¨dlÉ™É¥ Æ¨á´‰É¥Ê‡ É™doÉ¥ puÉ Ê»Î»Ép É™É”á´‰u É É™ÊŒÉÉ¥ Ê»ÊÉ”nl pooâ…   ğŸ˜ˆ 
    </font>
    </code>
</p>


</div>
<div class="slide">
<h1>What <i>is</i> this?

</h1><ul><li level="1">Get the current version from here:

<pre> http://training.perl.com/OSCON2011/index.html </pre></li><li level="1">Iâ€™ll often use ğŸª  as an abbreviation for <i>Perl</i>, and sometimes
for <i>perl</i> â€” as in, â€œIâ€™m running ğŸª  v5.14.â€

</li><li level="1">See <i>Appendix 1: Fonts</i> at the end of this talk for instructions on font set-up.

</li><li level="1">These slides was written in pod using <i>vi</i>, with the help of a
score of ğŸª Unicode tools available via the link in <i>Appendix 2: Tools</i>.

</li><li level="1">This slide show was built using <code>Pod::S5</code> by Tom Linden,
which in turn uses <code>S5</code> by Eric Meyer.  Slideshow controls appears
if you hover near the bottom right corner.

</li><li level="1">Iâ€™ve used next to no HTML tricks here; nearly all 
fancyâ€<i>qua</i>â€weird stuï¬€ you see here is actually Unicode.

</li></ul></div>
<div class="slide">
<h1>Welcome to Unicode!

</h1><ul><li level="1">Unicode isnâ€™t just â€œhereâ€ â€” Unicode is now 20 years old, and itâ€™s
here to stay.

</li><li level="1"><i>Every</i> programmer needs to understand it, at least a little.

</li><li level="1">Unicode is <i>not</i> just for <i>non</i>â€English; look closely at this page.

<li>This talk has its roots in a <a href="http://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default/6163129#6163129" target="_blank">StackOverï¬‚ow posting</a>.

</li><li level="1">I have a whole â€™nother talk on <b>Thursday at 4:10pm in Portland 256</b> entirely dedicated
to Unicode in Perl regular expressions. 

</li><li level="1">Therefore, this talk wonâ€™t talk <i>too</i> much about regexes, 
but if we run out of materials here this morning before we run out of morning, 
Iâ€™ll go through some of those here.  

</li></ul></div>
<div class="slide">
<h1>The Bad News

</h1><ul><li level="1">There exists no:

<ul><li level="1">envariable to set

</li><li level="1">CLI switch to turn on

</li><li level="1">pragma to declare

</li><li level="1">nor module to load

</li></ul><p>that will somehow â€œenable Unicode by defaultâ€ in your code.  

</p></li><li level="1">The very idea is a category error, because so long as you think of
Unicode as merely â€œlike ASCII/Latin1/CP1252/anything, but with more
charactersâ€, you will never grasp it. Thatâ€™s closer to ISOâ€10646, but
Unicode is <i>much</i> more than that.

</li><li level="1">No matter how much boilerplate you introduce, you are never going
to get your head into Unicode until you stop thinking of it as nothing
more than a bigger character set, which means you are never going to do
things â€œrightâ€.

</li></ul></div>
<div class="slide">
<h1>Surprise!

</h1><ul><li level="1"><i>Besides</i> having more characters, Unicode <i>also</i> includes 

<ul><li level="1">rules for casemapping and casefolding 

</li><li level="1">grapheme clusters, including combining characters

</li><li level="1">several diï¬€erent kinds of normalization forms

</li><li level="1">highly customizable rules for collation

</li><li level="1">rules for wordâ€ <i>&</i> lineâ€breaking

</li><li level="1">special rules for regular expressions

</li><li level="1">1000s of properties, including names and scripts

</li><li level="1">numeric equivalences (<i>e.g.</i>, telling you that U+216B, â€œâ…«â€, has the value 12)

</li><li level="1">print widths

</li><li level="1">bidirectionality

</li><li level="1">glyph variants

</li><li level="1"><i>&</i> much, <i>much</i> moreâ€¼ 

</li></ul></li></ul></div>
<div class="slide">
<h1>The Good News ğŸ˜» 

</h1><ul><li level="1">The good news is ğŸª  currently has <i><b>the</b></i> best Unicode support of any
programming language.  If you think <i>weâ€™ve</i> got it bad,
just try any of the other guys. Come to my <b>Unicode Support Shootout</b> talk at 5pm
on Thursday, and see why.

</li><li level="1">That doesnâ€™t mean Unicode in Perl (or anything) is hassleâ€free.  
A small set of common blunders exist that are far too is easy to get stuck on, 
seemingly forever.

</li><li level="1">This tutorial is frontâ€loaded to get across a few simple, basic
settings so that <i>that</i> never happens to you.  Itâ€™s to make the easy
stuï¬€ easy.

</li><li level="1">There <i>is</i> hard stuï¬€ involved with Unicode â€” and for the most
part, you <i>can</i> do them in ğŸª.  It just takes more work<i>&</i>care that 
the easy stuff.

</li><li level="1">Most of the really hard ones are beyond the scope of this tutorial, 
but we may touch on a few of those toward the end.

</li></ul></div>
<div class="slide">
<h1>Included ğŸª Unicode Tools

</h1><li level="1">Iâ€™ve included a directory full of ğŸª scripts which I ï¬nd useful in <i>Appendix 2: Tools</i>:

<ul><li level="1">Probing the UCD:
<code>unichars</code>,
<code>uninames</code>,
<code>uniprops</code>

</li><li level="1">For use with the <code>charnames</code> pragma:
<code>unicore/html_alias.pl</code>

</li><li level="1">Unix tool rewrites:
<code>tcgrep</code>,
<code>ucsort</code>,
<code>unifmt</code>,
<code>unilook</code>,
<code>uniquote</code> (a better <code>cat â€‘v</code> or <code>od</code>),
<code>uniwc</code>

</li><li level="1">Normalization ï¬lters and tools:
<code>nfc</code>,
<code>nfd</code>,
<code>nfkc</code>,
<code>nfkd</code>, 
plus <code>nfcheck</code>

</li><li level="1">Casing and fontâ€fun ï¬lters:
<code>uc</code>,
<code>lc</code>,
<code>tc</code>, 
plus <code>titulate</code>;
<code>unifont</code>,
<code>leo</code>,
<code>unicaps</code>,
<code>uninarrow</code>,
<code>uniwide</code>,
<code>unisubs</code>,
<code>unisupers</code>

</li><li level="1">Test/demo code:
<code>es-sort</code>,
<code>hantest</code>,
<code>havshpx</code>,
<code>hypertest</code>,
<code>nunez</code> (should be called <code>nÃºÃ±ez</code> or even better, <code>bÃºsqueda-libre</code>, but for ï¬lesys issues)

</li></ul></div>
<div class="slide">
<h1>ğŸª Unicode Tools: Setup

</h1><ul><li level="1">If you grab the tools, you can various examples of them I mention in this talk. 

</li><li level="1">When I run them, I have this environment set up:

<ul><li level="1">for <i>bash</i>

<pre> $ export PERL_UNICODE=CSD      # but see below
 $ export LESS=MQeicsnf
 $ alias pc 'perl5.14.0 -Mcharnames=:full,:short,latin,greek -E'
 $ alias ug=uninames
 $ alias um='ucsort | less -r' </pre></li><li level="1">for <i>tcsh</i>

<pre> % alias um 'ucsort | less -r'
 % alias ug uninames
 % alias pc 'perl5.14.0 -Mcharnames=:full,:short,latin,greek -E'
 % setenv PERL_UNICODE CSD
 % export LESS MQeicsnf </pre></li></ul></li></ul></div>
<div class="slide">
<h1>ğŸª Unicode Tools: ğ”ˆğ”µğ”¢ğ”ªğ”­ğ”©ğ”¦Â ğ”Šğ”¯ğ”ğ”±ğ”¦ğ”Â 

</h1><p>Here are simple examples to play with:

</p><pre> % pc 'say "\N{long s} \N{ae} \N{Omega} \N{omega}" \N{UPWARDS ARROW}'

 % echo exempli gratia | tc | unifont 

 % tcgrep -n '\P{ASCII}' pue.pod | uniquote -x | less
 % tcgrep -n '\P{ASCII}' pue.pod | uniquote -v | less

 % echo you are not expected to read this | leo

 % echo these are small caps | tc | unicaps
 % echo supers                    | unisupers
 % echo 123a                      | unisubs </pre></div>
<div class="slide">
<h1>ğŸª Unicode Tools: ğ”ˆğ”µğ”¢ğ”ªğ”­ğ”©ğ”¦Â ğ”Šğ”¯ğ”ğ”±ğ”¦ğ”Â  <i>(contÂ¹â€¦)</i>

</h1><p>Here are more interesting examples to play with:

</p><pre> % uninames latin ligat
 % uninames SIGN -arabic
 % uninames arrow -combining

 % uniprops 'MICRO SIGN'
 % uniprops -a 2010

 % unichars '\pL' '\p{Greek}'
 % unichars '\pL' '\p{Greek}' | um
 % unichars '\p{Age=6.0}'     | um
 % unichars -gasn NUM

 % unilook glob
 % unilook /glob
 % unilook -v '\pM'
 % unilook -v '\N{acute}'
 % unilook -v whom
 % unilook -vpn run </pre></div>
<div class="slide">
<h1>Basic Recommendations

</h1><ul><li level="1">Set your <code>PERL_UNICODE</code> envariable to <b><code>AS</code></b>. This makes all ğŸª
scripts decode <code>@ARGV</code> as UTFâ€8 strings, and sets the encoding of all
three of stdin, stdout, and stderr to UTFâ€8.   You may have to turn it
oï¬€ at times, though.  I donâ€™t recommend <b><code>D</code></b>.

</li><li level="1">At the top of your source ï¬le (program, module, library,
<code>do</code>hickey), prominently assert that you are running perl version 5.12
or better via:

<pre> use v5.12;  # minimal for unicode_strings feature
 use v5.14;  # optimal for unicode_strings feature </pre></li><li level="1">Declare this source unit as UTFâ€8. Once upon a time, this pragma did
other things, but it now serves this singular purpose alone and no other:

<pre> use utf8; </pre></li></ul></div>
<div class="slide">
<h1>Basic Recommendations <i>(contÂ¹â€¦)</i>

</h1><ul><li level="1">Enable (or reÃ«nable) strictures.

<pre> use strict; </pre></li><li level="1">Enable compiler warnings; weâ€™ll get to runtime warnings in a moment.

<pre> use warnings; </pre></li><li level="1">Fatalize UTFâ€8 warnings.

<pre> use warnings qw( FATAL utf8 ); </pre></li><li level="1">Under v5.14, the <code>utf8</code> warning class comprises three subwarnings
â€” <code>nonchar</code>, <code>surrogate</code>, and <code>non_unicode</code> â€” which you may sometimes
wish to exert greater (<i>i.e.</i>, separate) control over.

<pre> no warnings "non_unicode"; </pre></li></ul></div>
<div class="slide">
<h1>Basic Recommendations <i>(contÂ²â€¦)</i>

</h1><ul><li level="1">Declare that ï¬lehandles opened <i>within this lexical scope but not
elsewhere</i> are in UTFâ€8, until and unless you say otherwise.  The
<code>:std</code> adds in <code>STDIN</code>, <code>STDOUT</code>, and <code>STDERR</code>. 
This critical step
implicitly decodes incoming data and encodes outgoing data as UTFâ€8.

<pre> use open qw( :encoding(UTF-8) :std ); </pre></li><li level="1">Enable named characters via <code>\N{<i>CHARNAME</i>}</code>.

<pre> use charnames qw( :full ); </pre></li><li level="1">If you have a <code>DATA</code> handle, you must explicitly set its
encoding. If you want this to be UTFâ€8, then say:

<pre> binmode(DATA, ":encoding(UTF-8)"); </pre></li></ul></div>
<div class="slide">
<h1>Unicode Template

</h1><ul><li level="1">The next few slides show how I start all my ğŸª code these days.

</li><li level="1">They combine the previous directives and add a few niceties.

</li><li level="1">Some of the later elements may get omitted in some code, but
not the earlier ones.

</li><li level="1">The <code>#!</code> line is debatable. Consider it a shortcut for whatever
you need on your system: I try not to inï¬‚ict <i>perlrun</i>â€™s
<code>eval exec</code> hack on people. ğŸ˜’ 

</li><li level="1">ğŸœ  Unfortunately, 

<a href="https://rt.cpan.org/Public/Bug/Display.html?id=54777" target=_blank>
a known bug</a>
prevents the <code>open</code> pragma from working
correctly if youâ€™ve also used the <code>autodie</code> pragma:

<pre> https://rt.cpan.org/Public/Bug/Display.html?id=54777 </pre></li></ul></div>
<div class="slide">
<h1>Unicode Template: Pragmas

</h1><p>Donâ€™t take my <code>#!</code> here too seriously; it has Issues.

</p><pre> #!/usr/bin/env perl

 use v5.14;
 use utf8;

 use strict;
 use autodie;
 use warnings; 

 use warnings    qw&lt; FATAL utf8 >;
 use open        qw&lt; :std :encoding(UTF-8) >;
 use charnames   qw&lt; :full >;
 use feature     qw&lt; unicode_strings >; </pre></div>
<div class="slide">
<h1>Unicode Template: Modules

</h1><p>The ï¬rst of these is almost always needed; the rest, not so much.

</p><pre> use Unicode::Normalize  qw&lt; NFD NFC >;
 use Encode              qw&lt; encode decode >;

 use Carp                qw&lt; carp croak confess cluck >;
 use File::Basename      qw&lt; basename >;

 $0 = basename($0);  # shorter messages </pre></div>
<div class="slide">
<h1>Unicode Template: DATA, @ARGV

</h1><p>Donâ€™t make <code>$|</code> hot if you have a lot of output on <code>STDOUT</code>.

</p><pre> binmode(DATA, ":encoding(UTF-8)");
 
 # This works like perl -CA: note that it
 # assumes your terminal is set to use UTF-8
 if (grep /\P{ASCII}/ => @ARGV) { 
    @ARGV = map { decode("UTF-8", $_) } @ARGV;
 }
 
 $| = 1;   # comment out for performance

 END { close STDOUT } </pre></div>
<div class="slide">
<h1>Unicode Template: Set Traps

</h1><p>This avoids compileâ€time ğŸœ  â€œbugsâ€ in the pragma:

</p><pre> # XXX: use warnings FATAL => "all";
 
 local $SIG{__DIE__} = sub {
     confess "Uncaught exception: @_" unless $^S;
 };
 
 local $SIG{__WARN__} = sub {
     if ($^S) { cluck   "Trapped warning: @_" } 
     else     { confess "Deadly warning: @_"  }
 }; </pre></div>
<div class="slide">
<h1>Unicode Template: Filters

</h1><p>I use this on normal CLI ï¬lters:

</p><pre> if (@ARGV == 0 &amp;&amp; -t STDIN &amp;&amp; -t STDERR) {
    print STDERR "$0: reading input from tty, type ^D for EOF...\n";
 }

 while (&lt;>)  {
     chomp;
     $_ = NFD($_);
     ...
 } continue {
     say NFC($_);
 }
 
 __END__
 ğ–ğ–ğ–ˆ ğ–ğ–†ğ–ˆğ–Šğ–“ğ–™Â ğ–‰ğ–†ğ–™ğ–† ğ–šğ–“ğ–ğ–ˆğ–”ğ–‰ğ–ğ–ˆğ–† </pre></div>
<div class="slide">
<h1>ğŸª  Runtime Environment

</h1><ul><li level="1">The only ğŸªâ€related envariable I normally run with is
<code>PERL_UNICODE</code>, which I have set to <code>"SA"</code>. Thatâ€™s equivalent to
running with the <code>-CSA</code> commandâ€line option.  Possible values are

<ul><li level="1"><code><b>0</b></code>    = turn oï¬€ all ï¬‚ags (thatâ€™s a DIGIT ZERO)

</li><li level="1"><code><b>I</b></code>    = STDIN is assumed to be in UTFâ€8

</li><li level="1"><code><b>O</b></code>    = STDOUT will be in UTFâ€8

</li><li level="1"><code><b>E</b></code>    = STDERR will be in UTFâ€8

</li><li level="1"><code><b>S</b></code>    = <code><b>I</b></code> + <code><b>O</b></code> + <code><b>E</b></code>

</li><li level="1"><code><b>i</b></code>    = UTFâ€8 is the default PerlIO layer for input streams

</li><li level="1"><code><b>o</b></code>    = UTFâ€8 is the default PerlIO layer for output streams

</li><li level="1"><code><b>D</b></code>    = <code><b>i</b></code> + <code><b>o</b></code>

</li><li level="1"><code><b>A</b></code>    = the <code>@ARGV</code> elements are expected to be strings
encoded in UTFâ€8

</li><li level="1"><code><b>L</b></code>    = makes <code><b>"IOEioA"</b></code> conditional on the locale
environment variables (<code>LC_ALL</code>, <code>LC_TYPE</code>, and <code>LANG</code>, in order of
decreasing precedence) â€” if the variables indicate UTFâ€8, then the
selected <code><b>"IOEioA"</b></code> are in eï¬€ect.

</li></ul></li></ul></div>
<div class="slide">
<h1>ğŸª  Unicode Laundry List

</h1><ul><li level="1">That was the <i>easy</i> stuï¬€, but youâ€™ve got to get it out of the way
before you can go on.

</li><li level="1">Now weâ€™ll do the <i>real</i> work.

</li></ul></div>
<div class="slide">
<h1>ğŸœ  Ixnay on the Ugbay Already! ğŸœ

</h1><ul><li level="1">ğŸª used to have something called <b>â€œ<i>The</i> Unicode Bugâ€</b> ğŸœ .

</li><li level="1">Essentially, it caused code points in the range 128â€“255 to be
treated as binary, not text.

</li><li level="1">If you follow my instructions above, you should no longer be
aï¬€ected by it.

</li><li level="1">The critical ï¬x that makes it all possible is

<pre> use feature "unicode_strings"; </pre></li><li level="1">This feature was ï¬rst introduced in v5.12, but didnâ€™t come 
up to full functionality until v5.14.

</li></ul></div>
<div class="slide">
<h1>Core Pragmas

</h1><ul><li level="1">Key core pragmas for Unicode are:

<ul><li level="1"><code>v5.14</code>

</li><li level="1"><code>utf8</code>

</li><li level="1"><code>feature</code>

</li><li level="1"><code>charnames</code>

</li><li level="1"><code>open</code>

</li><li level="1"><code>re "/<i>flags</i>"</code>

</li><li level="1"><code>encoding::warnings</code>

</li></ul></li><li level="1">Probably best to stay clear of these, though:

<ul><li level="1"><code>bytes</code>

</li><li level="1"><code>encoding</code>

</li><li level="1"><code>locale</code>

</li></ul></div>
<div class="slide">
<h1>Program Literals

</h1><p>Specify Unicode literals any of these ways:

</p><ol><li level="1"><p>As literal UTFâ€8 under the recommended <code>utf8</code> pragma, allowing you to
write <code>"Ã  contre-cÅ“ur"</code>, <code>"Ã…ngstrÃ¶m"</code>, or  <code>"ğŸ‘ª ğŸ’— ğŸª"</code> directly.

</p></li><li level="1"><p>As wicked â€œmagic numbersâ€ like <code>chr(0x1F4A9)</code>, <code>"\x{2639}"</code>, or <code>"\N{U+A0}"</code>.

</p></li><li level="1"><p>Using the <code>charnames</code> pragma and the <code>\N{<i>CHARNAME</i>}</code>
construct, strings like <code>"\N{LATIN SMALL LETTER A WITH GRAVE} 
contre-c\N{LATIN SMALL LIGATURE OE}ur"</code>, <code>"A\N{COMBINING RING
ABOVE}ngstro\N{COMBINING DIAERESIS}m"</code>, and <code>"\N{FAMILY} 
\N{GROWING HEART} \N{DROMEDARY CAMEL}"</code>.

</p></li></ol></div>
<div class="slide">
<h1>The <i>charnames</i> Pragma

</h1><ul><li level="1">Works on any interpolated string, including regexes.

</li><li level="1">Must be available at compileâ€time.

</li><li level="1"><b>âš  </b> Diï¬€erent scopes can have diï¬€erent name bindings. 

</li><li level="1">Import any combination of <code>:full</code>, 
<code>:short</code>, 
<code><i>SCRIPTNAME</i></code>,
or
<code>:alias</code>.

</li><li level="1">Also provides several functions (not for import):

<ul><li level="1"><code>charnames::string_vianame(<i>name</i>)</code> for runtime lookup of either
a character name or a named character sequence, returning its string
representation

</li><li level="1"><code>charnames::vianame(<i>name</i>)</code> for runtime lookup of a character
name (but <i>not</i> a named character sequence) to get its ordinal value
(code point)

</li><li level="1"><code>charnames::viacode(<i>code</i>)</code> for runtime lookup of a code point
to get its Unicode name.

</li></ul></li></ul></div>
<div class="slide">
<h1>Basic <i>charnames</i> Examples

</h1><ul><li level="1">Using full or short character names

<pre> use charnames ":full";
 print "\N{GREEK CAPITAL LETTER DELTA} is delta.\n";
    # Î” is delta.

 use charnames ':short';
 print "\N{greek:Delta} is an upper-case delta.\n";
    # Î” is an upper-case delta. </pre></li><li level="1">By script name

<pre>  use charnames qw(cyrillic greek);
  print "Sigmata are \N{Sigma}, \N{sigma}, and \N{final sigma}.\n";
    # Sigmata are Î£, Ïƒ, and Ï‚.
  print "\N{Be} and \N{be} are Cyrillic B's.\n";
    # Ğ‘ and Ğ± are Cyrillic B's. </pre></li></ul></div>
<div class="slide">
<h1>Custom <i>charnames</i> Examples

</h1><ul><li level="1">Customization via <code>:alias</code> and a hash:

<pre> use charnames ":full", ":alias" => {
     e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
     E_ACUTE => "LATIN CAPITAL LETTER E WITH ACUTE",
 };
 print "I'll have the \N{e_ACUTE}touff\N{e_ACUTE}e.\n";
    # I'll have the Ã©touffÃ©e. </pre></li><li level="1">Customization via <code>:alias</code> and a string looks for a corresponding
ï¬le to require from <code>unicore/</code>, which must be a subdirectory under your
<code>@INC</code> path. For example, <code>:<b>html</b></code> would look for a ï¬le named
<code>unicore/<b>html</b>_alias.pl</code>.

<pre> use charnames ":alias" => ":html";
 print "\N{frac14} and \N{frac12} are \N{frac34}.\n";
    # Â¼ and Â½ are Â¾. </pre></li></ul></div>
<div class="slide">
<h1>Core Modules

</h1><p>Key core modules for Unicode are:

</p><ul><li level="1"><code>Encode</code>

</li><li level="1"><code>Unicode::Normalize</code>

</li><li level="1"><code>Unicode::Collate</code>

</li><li level="1"><code>Unicode::Collate::Locale</code>

</li><li level="1"><code>Unicode::UCD</code>

</li><li level="1"><code>DBM_Filter::utf8</code>

</li></ul></div>
<div class="slide">
<h1>The <i>Encode</i> module

</h1></li><li level="1">The <code>Encode</code> module is most often used implicitly: itâ€™s
loaded automatically whenever you pass an <code>:encoding(<i>ENC</i>)</code> 
argument to <code>binmode</code> or to <code>open</code>.

<pre> binmode(STDIN,       ":encoding(cp1252)")
               || die "can't binmode STDIN: $!";

 open(OUTPUT, "> :raw :encoding(UTF-16LE) :crlf", $filename) 
               || die "can't open $filename: $!";

 print OUTPUT while &lt;STDIN>;

 close(OUTPUT) || die "couldn't close $filename: $!";
 close(STDIN)  || die "couldn't close STDIN: $!"; </pre></div>
<div class="slide">
<h1>The <i>Encode</i> module <i>(contÂ¹â€¦)</i>

</h1><ul><li level="1">The <code>Encode</code> module provides functions for when you need to
manually decode incoming data and to manually encode outgoing data.

</li><li level="1">The functions I most often use from it are <code>encode</code>, <code>decode</code>,
and <code>find_encoding</code>.

<pre> use Encode qw&lt; find_encoding >;
 for my $alias (qw&lt; utf8 UTF-8 utf16le >) {
     my $obj = find_encoding($alias);
     my $name = $obj ? $obj->name() : "UNKNOWN";
     printf "%-8s is really %s.\n", $alias, $name;
 } 

 # utf8     is really utf8.
 # UTF-8    is really utf-8-strict.
 # utf16le  is really UTF-16LE. </pre></li><li level="1">Try running my <i>byte2uni</i> tool like this for a blast from the past:

<pre> % byte2uni -a -e nextstep | less </pre></li></ul></div>
<div class="slide">
<h1>The <i>Encode</i> module <i>(contÂ²â€¦)</i>


</h1><p>The MacRoman encoding is a bit weird:

</p><pre> use charnames qw&lt; :full >;
 use Encode (
     "decode",   # $unicode = decode("scheme", $bytes);
     "encode",   # $bytes   = encode("scheme", $unicode);
 );

 my $permil = "\N{PER MILLE SIGN}";
 printf "A permille %s is U+%vX in Unicode", $permil, $permil;

 my $bytes = encode("macroman", $permil);
 printf " but is 0x%vX in Macroman\n", $bytes;

    # A permille â€° is U+2030 in Unicode but is 0xE4 in Macroman </pre></div>
<div class="slide">
<h1>The <i>Encode</i> module <i>(contÂ³â€¦)</i>

</h1><p>The MacRoman encoding is <i>still</i> a bit weird:

</p><pre> use charnames qw&lt; :full >;
 use Encode (
     "decode",   # $unicode = decode("scheme", $bytes);
     "encode",   # $bytes   = encode("scheme", $unicode);
 );

 my $byte = chr(0x8E);
 my $char = decode("macroman", $byte);

 printf "An %vX in MacRoman is %vX in Unicode\n", $byte, $char;
 printf "Which is really a %s\n", charnames::viacode(ord $char);

    # An 8E in MacRoman is E9 in Unicode
    # Which is really a LATIN SMALL LETTER E WITH ACUTE </pre></div>
<div class="slide">
<h1>The <i>Unicode::Normalize</i> module

</h1><ul><li level="1">Because equivalent grapheme clusters can be written multiple ways,
you almost always want to normalize your data using functions from the
standard <code>Unicode::Normalize</code> module.

</li><li level="1">Thatâ€™s why my standard template said:

<pre> while (&lt;>)  {
     chomp;
     $_ = NFD($_);
     ...
 } continue {
     say NFC($_);
 } </pre></li></ul></div>
<div class="slide">
<h1>Canonical Conundra

</h1><p>Just as one example, consider all these variants of a Latin small letter
<i>o</i> with tilde:

</p><!--

use v5.14;
use Unicode::Normalize;
my @s = (
    "\x{F5}",
    "o\x{303}",
    "\x{22D}",
    "\x{F5}\x{304}",
    "o\x{303}\x{304}",
    "o\x{304}\x{303}",
    "\x{14D}\x{303}",
);
my $count = 1;
for my $s (@s) {
    print $count++, " ";
    print "NFD" if $s eq NFD($s);
    print "NFC" if $s eq NFC($s);
    print "\n";
} 

1 NFC
2 NFD
3 NFC
4 
5 NFD
6 NFD
7 NFC

-->

<table width="100%" border=1>

<tr>
<th>N</th>
<th>Glyph</th>
<th>NFC?</th>
<th>NFD?</th>
<th>ğŸªğŸªğŸªğŸªğŸª</th>
<th>Code Points</th>
</tr>

<tr>
    <td>1</td>
    <td align=center><b><font face="Times New Roman">Ãµ</font></b></td>
    <td align=center>âœ“</td>
    <td align=center>â”€</td>
    <td><code>"\x{F5}"</code></td>
    <td><code><font size="-2">LATIN SMALL LETTER O WITH TILDE</font></code></td>
</tr>

<tr>
    <td>2</td>
    <td align=center><b><font face="Times New Roman">oÌƒ</font></b></td>
    <td align=center>â”€</td>
    <td align=center>âœ“</td>
    <td><code>"o\x{303}"</code></td>
    <td><code><font size="-2">LATIN SMALL LETTER O, COMBINING TILDE</font></code></td>
</tr>

<tr>
    <td>3</td>
    <td align=center><b><font face="Times New Roman">È­</font></b> </td>
    <td align=center>âœ“</td>
    <td align=center>â”€</td>
    <td><code>"\x{22D}"</code></td>
    <td><code><font size="-2">LATIN SMALL LETTER O WITH TILDE AND MACRON</font></code></td>
</tr>

<tr>
    <td>4</td>
    <td align=center><b><font face="Times New Roman">ÃµÌ„</font></b></td>
    <td align=center>â”€</td>
    <td align=center>â”€</td>
    <td><code>"\x{F5}\x{304}"</code></td>
    <td><code><font size="-2">LATIN SMALL LETTER O WITH TILDE, COMBINING MACRON</font></code></td>
</tr>

<tr>
    <td>5</td>
    <td align=center><b><font face="Times New Roman">oÌƒÌ„</font></b></td>
    <td align=center>â”€</td>
    <td align=center>âœ“</td>
    <td><code>"o\x{303}\x{304}"</code></td>
    <td><code><font size="-2">LATIN SMALL LETTER O, COMBINING TILDE, COMBINING MACRON</font></code></td>
</tr>

<tr>
    <td>6</td>
    <td align=center><b><font face="Times New Roman">ÅÌƒ</font></b></td>
    <td align=center>â”€</td>
    <td align=center>âœ“</td>
    <td><code>"o\x{304}\x{303}"</code></td>
    <td><code><font size="-2">LATIN SMALL LETTER O, COMBINING MACRON, COMBINING TILDE</font></code></td>
</tr>

<tr>
    <td>7</td>
    <td align=center><b><font face="Times New Roman">ÅÌƒ</font></b></td>
    <td align=center>âœ“</td>
    <td align=center>â”€</td>
    <td><code>"\x{14D}\x{303}"</code></td>
    <td><code><font size="-2">LATIN SMALL LETTER O WITH MACRON, COMBINING TILDE</font></code></td>
</tr>

</table>

</div>
<div class="slide">
<h1>Oh shucks...

</h1><ul><li level="1">Assuming you enforce NFD on input, then 1 shows up as 2, both of 3
<i>&</i> 4 show up as 5, and 7 shows up as 6.

</li><li level="1">Assuming you enforce NFC on output, then 2 shows up as 1, both of
4 <i>&</i> 5 show up  as 3, and 6 shows up as 7.

</li><li level="1">That means that by normalizing to <i>either</i> NFD <i>or</i> NFC, you can
do a simple <code>eq</code> to get 1 <i>&</i> 2, 3â€“5, and 6 <i>&</i> 7 to each
respectively test equal to one another.

</li><li level="1">Notice, however, that thatâ€™s three diï¬€erent sets.

</li><li level="1">Number 4 is in <i>neither</i> NFC <i>nor</i> NFD.  These things happen.
It gets worse.  Normalize.  Always.  Please.

</li></ul></div>
<div class="slide">
<h1>... and more shucks!

</h1><p>In a regex, all 7 of those will be completely matched by <code>\X</code>, an
extended grapheme cluster. Yes, but now what? ğŸ˜­ Iâ€™m afraid this is
where it stops being easy.  NFD is assumed <i>and required</i> for the
following to work:

</p><ul><li level="1"><code>/^o/</code> reports that all 7 start with an <i>o</i>.

</li><li level="1"><code>/^o\x{COMBINING TILDE}/</code> reports that 1â€“5 start with an <i>o</i> and
a tilde, but that misses 6 <i>&</i> 7.

</li><li level="1">Youâ€™d need <code>/^o\pM*?\x{COMBINING TILDE}/</code> to get all 7 matching.

</li><li level="1">This is still just a stab, with various issues still unresolved
(like using <code>\p{Grapheme_Extend}</code> instead of <code>\pM</code> â€” and, were there
any, using <code>\p{Grapheme_Base}</code> instead of <code>\PM</code>):

<pre> $o_tilde_rx = qr{ o \pM *? \x{COMBINING TILDE} \pM* }x; </pre></li></ul></div>
<div class="slide">
<h1>ğŸ‘½ Filesystems Hate You

</h1><ul><li level="1">You are going to have ï¬lesystem issues, especially on ğŸ‘½
ï¬lesystems.

</li><li level="1">Some ï¬lesystems silently enforce a conversion to NFC;
others silently enforce a conversion to NFD. And others do
something else still.

</li><li level="1">Some even ignore the matter altogether, which leads to even
greater problems.

</li><li level="1">So you really do have to do your own NFC/NFD handling to keep
sane. I think.  Maybe.

</li></ul></div>
<div class="slide">
<h1>The <i>Unicode::Collate</i> module

</h1><ul><li level="1">Partly for reasons just shown, string comparisons on Unicode 
are pretty much always the wrong way to go.  

</li><li level="1">That includes <code>eq</code>, <code>ne</code>, <code>le</code>, <code>gt</code>, <code>cmp</code>, 
<code>sort</code>, <i>&c &c</i>. ğŸ˜“ 

</li><li level="1">Enter the standard <code>Unicode::Collate</code> module.  Itâ€™s superâ€fancy,
so Iâ€™ll just show the simplest approaches here.

</li><li level="1">You can get a taste for how it works by playing around with my <b><i>ucsort</i></b> utility.

</li></ul></div>
<div class="slide">
<h1>Replacing <i>sort</i>

</h1><ul><li level="1">Whenever youâ€™ve an array of <i>text strings</i> to sort, as in 
<code>@a = sort @b</code>, just swap that code out for this 
and all will be well:

<pre> use Unicode::Collate;
 @sorted = Unicode::Collate::->new->sort(@unsorted); </pre></li><li level="1">Thereâ€™s also a standard <code>Unicode::Collate::Locale</code> module 
for national sorts.

<pre> use Unicode::Collate::Locale;

 state $coll = new Unicode::Collate::Locale::
                   locale => "fr",
       # lots of other parameters possible here
               ;

 my @bons_mots = $coll->sort(our @mots); </pre></li></ul></div>
<div class="slide">
<h1>Replacing <i>eq</i>

</h1><ul><li level="1">Most realâ€world sorts are more complex than those.

<pre> @srecs = sort {
     $b->{AGE}   &lt;=>  $b->{AGE}
                 ||
     $a->{NAME}  cmp  $b->{NAME}
 } @recs; </pre></li><li level="1">Enter the <code>getSortKey</code> method:

<pre> my $collator = Unicode::Collate::->new();
 for my $rec (@recs) {
     $rec->{NAME_key} = $collator->getSortKey($rec->{NAME});
 } 
 @srecs = sort {
     $b->{AGE}       &lt;=>  $b->{AGE}
                     ||
     $a->{NAME_key}  cmp  $b->{NAME_key}
 } @recs; </pre></li></ul></div>
<div class="slide">
<h1>Program Options to <i>ucsort</i> 

</h1><p>These are its literal <code>Getopt:::Long</code> arguments:

</p><pre>  # collator constructor options
    --backwards-levels=i
    --collation-level|level|l=i
    --katakana-before-hiragana
    --normalization|n=s
    --override-CJK=s
    --override-Hangul=s
    --preprocess|P=s
    --upper-before-lower|u
    --variable=s

  # program specific options
    --case-insensitive|insensitive|i
    --input-encoding|e=s
    --locale|L=s
    --paragraph|p
    --reverse-fields|last
    --reverse-output|r
    --right-to-left|reverse-input </pre></div>
<div class="slide">
<h1>CPAN Modules

</h1><p>CPAN modules for handling Unicode include:

</p><ul><li level="1"><code>Unicode::LineBreak</code>, which includes <code>Unicode::GCString</code>. These
respectively solve â€œthe <code>format</code> problemâ€ and â€œthe <code>printf</code> problemâ€.

</li><li level="1"><code>Unicode::Casing</code> for things like 
<code>lc</code> <i>Î£Î¤Î™Î“ÎœÎ‘Î£</i> â‡’  <i>ÏƒÏ„Î¹Î³Î¼Î±Ï‚</i> in Greek, or <code>uc</code> <i>i</i> â‡’  <i>Ä°</i> in the Turkic languages.

</li><li level="1"><code>Unicode::Unihan</code>, and
if you liked the last one, you might want to look into
<code>Lingua::JA::Romanize::Japanese</code>,
<code>Lingua::KO::Hangul::Util</code>,
<code>Lingua::KO::Romanize::Hangul</code>,
<code>Lingua::ZH::Romanize::Pinyin</code>, <i>&c</i>.

</li><li level="1"><code>Unicode::Stringprep</code>

</li></ul></div>
<div class="slide">
<h1>No POSIX Locales, <i>por favor</i>

</h1><ul><li level="1">Please don't (try to) use POSIX localesâ€™ collation.  Use Unicodeâ€™s.

</li><li level="1">Normalization wonâ€™t always help you enough.  For example, you
canâ€™t use it to get <i>o</i>, <i>Ãµ</i>, and <i>Ã¸</i> to look the same, because
<code>LATIN SMALL LETTER O WITH STROKE</code> has no decomposition to something
with an <i>o</i> in it.

</li><li level="1">When comparing whether letters are the same, <code>Unicode::Collate</code>
<i>does</i> count <i>o</i>, <i>Ãµ</i>, and <i>Ã¸</i> as the same letter â€” normally.  Not
in Swedish or Hungarian, though.

</li><li level="1">Similarly with <i>d</i> and <i>Ã°</i> â€” you canâ€™t decompose <code>LATIN SMALL
LETTER ETH</code> to anything with a <i>d</i> in it, but the UCA treats them as
the same letter.  <i>Er</i>, except in Icelandic (the <code>"is"</code> locale), where
<i>d</i> and <i>Ã°</i> are now diï¬€erent letters in their own right.

</div>
<div class="slide">
<h1>Unicode Locales

</h1><ul><li level="1">What about <i>ae</i> <i>&</i> <i>Ã¦</i> <code>\x{E6}</code>, or <i>oe</i> <i>&</i> <i>Å“</i> <code>\x{153}</code>?  Those arenâ€™t
casefolds of each other as occurs with <i>ij</i> and <i>Ä³</i> <code>\x{133}</code>, 
and thereâ€™s no useful decomposition, either.  But <code>Unicode::Collate</code> <i>will</i> treat them
alike. 

</li><li level="1">Usually, that is. <i>However</i>, in the â€œGerman phonebookâ€ locale, <b>now</b> <i>ae</i> and <i>Ã¦</i>
are diï¬€erent â€” but <i>ae</i> and <i>Ã¤</i> 
(whether written <code>\x{E4}</code> or <code>a\x{308}</code>)
are the same.  No kidding.

</li><li level="1">Hereâ€™s how to do a locale compare: 

<pre> state $coll = new Unicode::Collate::Locale:: 
                locale => "de__phonebook", 
            ;

 if ($coll->eq($a, $b)) { ... } </pre></li><li level="1">Now what? Itâ€™s tough, I tell you.  
See my collation examples in my
<code>FixString.pm</code> module and my 
<i>es-sort</i>,
<i>nÃºÃ±ez</i>, and 
<i>unilook</i> tools.

</li></ul></div>
<div class="slide">
<h1>Unicode Regex Gotchas

</h1><ul><li level="1">Code that uses <code>\p{Lu}</code> is almost as wrong as code that uses 
<code>[A-Za-z]</code>.  You need to use <code>\p{Upper}</code> instead, because
<code>\p{Lowercase}</code> (â‰¡ <code>\p{Lower}</code>) <b><i>is diï¬€erent</i></b> from 
<code>\p{Lowercase_Letter}</code> (â‰¡ <code>\p{Ll}</code>) by 159 code points:

<pre> % unichars '\p{Lowercase}' '\P{Lowercase_Letter}' 
 % unichars '\p{Lower}'     '\P{Ll}'  # same but easier to type </pre></li><li level="1">Code that uses <code>[a-zA-Z]</code> is even worse.  And it canâ€™t use <code>\pL</code>
or <code>\p{Letter}</code>; it needs to use <code>\p{Alphabetic}</code>. Not all alphabetics
are letters:

<pre> % unichars -a '\p{alphabetic}' '\P{Letter}' | wc -l # 1006 code points </pre></li><li level="1">If you are looking for ğŸª variables with <code>/[\$\@%]\w+/</code>, then you
have a problem (or two).  

<ul><li level="1">You need to look for <code>/[\$\@%]\p{IDS}\p{IDC}*/</code>

</li><li level="1">Even that isnâ€™t thinking about the punctuation variables or package
variables.

</li></ul></li></ul></div>
<div class="slide">
<h1>Unicode Regex Gotchas <i>(contÂ¹â€¦)</i>

</h1><ul><li level="1">If you are checking for whitespace, then you should choose between
<code>\h</code> and <code>\v</code>, depending.  And you should never use <code>\s</code> to mean all possible Unicode whitespace.

</li><li level="1">For historical reasons, <code>\s</code>
<b><i>does not mean</i></b> <code>[\h\v]</code>.  These both tell the same tale:

<pre> % unichars '\S' '[\v\h]' 
  ---- U+000B LINE TABULATION

 % unichars '\S' '\p{space}'   
  ---- U+000B LINE TABULATION </pre></div>
<div class="slide">
<h1>Unicode Regex Gotchas <i>(contÂ²â€¦)</i>

</h1><ul><li level="1">If you are using <code>\n</code> for a line boundary, or even <code>\r\n</code>, then
you are doing it wrong.  

</li><li level="1">The Unicode linebreak sequence metacharacter is <code>\R</code>.  It means <code>(?:\r\n|\v)</code>.

<pre> % unichars '\R'
  ---- U+000A LINE FEED (LF)
  ---- U+000B LINE TABULATION
  ---- U+000C FORM FEED (FF)
  ---- U+000D CARRIAGE RETURN (CR)
  ---- U+0085 NEXT LINE (NEL)
  ---- U+2028 LINE SEPARATOR
  ---- U+2029 PARAGRAPH SEPARATOR </pre></li><li level="1">You <i>could</i> always canonicalize to linefeeds:

<pre> my $slurpy = `cat somefile`;    # pretend I didnâ€™t do this :)
    $slurpy =~ s/\R/\n/g;        # convert Unicode linebreaks </pre></li></ul></div>
<div class="slide">
<h1>Unicode Antipatterns ğŸ’©

</h1><p>People
make millions of broken assumptions 
about Unicode. Until they understand these things, their  ğŸª code
will be broken. Look for these <i><b>Unicode antipatterns</b></i>:

</p><ul><li level="1">Code that assumes it can open a text ï¬le without specifying the
encoding is broken.

</li><li level="1">Code that assumes the default encoding is some sort of native
platform encoding is broken.

</li><li level="1">Code that assumes web pages in Japanese or Chinese take up
less space in UTFâ€16 than in UTFâ€8 is wrong.

</li><li level="1">Code that assumes ğŸª uses UTFâ€8 internally is wrong.

</li><li level="1">Code that assumes encoding errors will always raise an
exception is wrong.

</li><li level="1">Code that assumes ğŸª code points are limited to 0x10_FFFF is wrong.

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(contÂ¹â€¦)</i>

</h1><ul><li level="1">Code that assumes you can set <code>$/</code> to something that will work
with any valid line separator is wrong. <code>\R</code> only works in patterns.

</li><li level="1">Code that assumes roundrip equality on casefolding, like
<code>lc(uc($s)) eq $s</code> or <code>uc(lc($s)) eq $s</code>, is completely borken and
worng.  Consider that the <code>uc("Ïƒ")</code> and <code>uc("Ï‚")</code>  are both <code>"Î£"</code>,
but <code>lc("Î£")</code> cannot possibly return both of those.

</li><li level="1">Code that assumes every lowercase code point has a distinct
uppercase one, or vice versa, is broken. For example, <code>"Âª"</code> is a
lowercase letter with no uppercase.   Kinda.

</li><li level="1">Whereas both <code>"áµƒ"</code> and <code>"á´¬"</code> <i>are</i> <code>Cased</code> letters, they casemap
only to themselves. Both <i>are</i> <code>Lowercase</code>, and <code>Letter</code>s, but they are not
<code>Lowercase_Letter</code>s. 

</li><li level="1">Got that? They are <i>not</i> <code>\p{Lowercase_Letter}</code>, despite being
both <code>\p{Letter}</code>s and <code>\p{Lowercase}</code>.  Theyâ€™re <code>\p{Modifier_Letter}</code>s, 
actually.  Honest.

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(contÂ²â€¦)</i>

</h1><ul><li level="1">Code that assumes changing the case doesnâ€™t change the length of
the string is broken.

<pre> % unichars -gas 'grep { length > 1 } lc, ucfirst, uc' </pre></li><li level="1">Code that assumes there are only two cases is broken. Thereâ€™s also
titlecase.

<pre> % unichars -gas 'uc ne ucfirst' </pre></li><li level="1">Code that assumes only letters have <code>Case</code> is broken. 
Beyond just letters, it turns out that numbers, symbols, and even marks have case.

<pre> % unichars -gas '\PL' '\p{Cased}' </pre></li><li level="1">Code that assumes casemapping a <code>Cased</code> code point always gives a diï¬€erent code point is broken.
This shows there are 1299 unâ€“caseâ€changing cased code points:

<pre> % unichars -gas '\p{Cased}' '[^\p{CWL}\p{CWT}\p{CWU}]' </pre></li><li level="1">Code that assumes case is <i>never</i> localeâ€dependent is broken, as is
code that assumes Unicode gives a ï¬ckle ï¬‚ying ï¬g about legacy POSIX locales.

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(contÂ³â€¦)</i>

</h1><ul><li level="1">Code that uses something like <code>y/\000-\177/\200-\377/</code> is broken
and wrong.
Try <code>tr[\0-\x{10_FFFF}][\x{20_0000}-\x{30_FFFF}]</code> if you dare.

</li><li level="1">Code that assumes it can remove <code>Mark</code>s to get â€œASCIIâ€
letters is 

<a href="http://www.catb.org/jargon/html/E/evil-and-rude.html" target=_blank>
evil and rude</a>.

</li><li level="1">Code that assumes diacritics <code>\p{Diacritic}</code> and marks
<code>\p{Mark}</code> are the same thing is broken.

<pre> % unichars -gas '\p{mark}' '\P{DIACRITIC}'   # 1068 code points
 % unichars -gas '\P{MARK}' '\p{diacritic}'   #  209 code points </pre></li><li level="1">Code that assumes the general category <code>\p{GC=Dash_Punctuation}</code> covers as much as
the binary property <code>\p{Dash=Yes}</code> is broken.

</li><li level="1">Code that naÃ¯vely assumes dash, hyphens, and minuses are all the 
same thing as each other, or that there is only one of each, is 
broken and wrong.  

<pre> % unichars -gas '\p{Dash}' </pre></li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(contâ´â€¦)</i>

</h1><ul><li level="1">Code that assumes every code point takes up no more than one print
column is broken. 

</li><li level="1">Code that assumes all <code>\p{Mark}</code>
characters take up zero print columns is broken.

<pre> % unichars -gas '\pM' '\P{BC=NSM}' </pre></li><li level="1">Code that assumes characters which look alike <i>are</i> alike
is broken.

</li><li level="1">Code that assumes characters which do <i>not</i> look alike are
<i>not</i> alike is broken.

</li><li level="1">Code that assumes there is a limit to the number of code points in
a row that just one <code>\X</code> can match is wrong.

</li><li level="1">Code that assumes <code>\X</code> can never start with a <code>\p{Mark}</code>
character is wrong.

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(contâµâ€¦)</i>

</h1><ul><li level="1">Code that assumes <code>\X</code> can never hold two nonâ€<code>\p{Mark}</code>
characters is wrong.

</li><li level="1">Code that assumes it cannot use <code>"\x{FFFF}"</code> is wrong.

</li><li level="1">Code that assumes a nonâ€BMP code point requiring two UTFâ€16
(surrogate) â€œcode unitsâ€ will encode to two separate UTFâ€8 characters, one
per code unit, is wrong. It doesnâ€™t: it encodes to a single code point.
<b>Or should.</b>

</li><li level="1">Code that transcodes from UTFâ€16 or UTFâ€32 with leading BOMs into
UTFâ€8 is broken if it puts a BOM at the start of the resulting UTFâ€8, because
it just changed the number of code points in the data!  <b>WÊ€á´É´É¢â€¼</b>

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(contâ¶â€¦)</i>

</h1><ul><li level="1">Code that assumes the CESUâ€8 is a valid UTF encoding is wrong.
Likewise, code that thinks encoding U+0000 as bytes <code>"\xC0\x80"</code> is UTFâ€8 is
broken and wrong. 

</li><li level="1">Code that assumes characters like < always points to the
right and > always points to the left are wrong â€” because they in
fact do not.

<pre> % perl -Mcharnames=:full -E 'say "\N{RLE}", "12 &lt; 345 &lt; 6789"'
 6789 > 345 > 12
 % perl -Mcharnames=:full -E 'say "\N{RLO}", "12 &lt; 345 &lt; 6789"'
 9876 > 543 > 21 </pre></li><li level="1">Code that assumes if you ï¬rst output character <code>X</code> and then
character <code>Y</code>, that those will show up as <code>XY</code> is wrong. Sometimes
they donâ€™t.

</li><li level="1"><b>Code that assumes ASCII is good enough for writing English
properly is stupid, shortsighted, illiterate, broken, evil, and wrong.</b>

</li><li level="1">I have stronger words for it, too.

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(contâ·â€¦)</i>

</h1><ul><li level="1">Code that assumes all <code>\p{Math}</code> code points are visible
characters is wrong.

</li><li level="1">Code that assumes <code>\w</code> contains only letters, digits, and
underscores is wrong â€” unless you use the <code>/a</code> modiï¬er or

<pre>    use re "/a"; </pre></li><li level="1">Code that assumes <code>^</code> and <code>~</code> are punctuation marks is
wrong.

</li><li level="1">Code that assumes <i>Ã«</i> has an umlaut character in it is wrong, thrice.

</li><li level="1">Code that believes symbols like <code>ã‚</code>, <code>â„‰</code>, <code>ã¨</code>,  <code>â‚¨</code>, <i>&</i> <code>â„¢</code> contain any letters in
them is wrong â€” except in NFKD:

<pre>  % unichars -gas '\pS' 'NFKD =~ /\p{Latin}/' | ucsort | less -r </pre></li><li level="1">Code that believes <code>\p{InLatin}</code> is the same as <code>\p{Latin}</code> is
heinously broken.

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(contâ¸â€¦)</i>

</h1><ul><li level="1">Code that believes <code>\p{InLatin}</code> is almost ever useful is
almost certainly wrong.

</li><li level="1">Code that believes that, given <code>$FIRST_LETTER</code> as the ï¬rst letter
in some alphabet and <code>$LAST_LETTER</code> as the last letter in that same
alphabet, writing <code>[${FIRST_LETTER}-${LAST_LETTER}]</code> has any meaning
whatsoever is almost always complete broken and wrong and meaningless.

</li><li level="1">Code that believes someoneâ€™s name can only contain certain
characters is oï¬€ensive, broken, and wrong.

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(contâ¹â€¦)</i>

</h1><ul><li level="1">Code that believes thereâ€™s some way to pretend textï¬le
encodings donâ€™t exist is broken and dangerous. 

</li><li level="1">Code that converts unknown characters to <code>?</code> is broken, stupid,
braindead, and runs contrary to the standard recommendation, which says
<i>not to do that!</i> So donâ€™t.

</li><li level="1">Code that believes it can reliably guess the encoding of an
unmarked textï¬le is guilty of a fatal mÃ©lange of hubris and naÃ¯vetÃ© that
only a lightning bolt from Zeus will ï¬x.

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(contÂ¹â°...)</i>

</h1><ul><li level="1">Code that believes you can use ğŸª <code>printf</code> widths to pad and
justify Unicode data is broken and wrong. Use <code>Unicode::GCString</code> to count columns.

</li><li level="1">Code that believes once you successfully create a ï¬le by a given
name, that when you run <code>ls</code> or <code>readdir</code> on its enclosing directory,
youâ€™ll actually ï¬nd that ï¬le with the name you created it under is
buggy, broken, and wrong. Stop being surprised by this!

</li><li level="1">Code that believes UTFâ€16 is a ï¬xedâ€width encoding is stupid,
broken, and wrong. 

</li><li level="1">Code that treats code points from one plane one whit diï¬€erently
than those from any other plane is <i>ipso facto</i> broken and wrong. 

</li></ul></div>
<div class="slide">
<h1>Antipatterns <i>(contÂ¹Â¹...)</i>

</h1><ul><li level="1">Code that believes that stuï¬€ like <code>/s/i</code> can match only <code>"S"</code> or
<code>"s"</code> is broken and wrong. Youâ€™d be surprised!

</li><li level="1">Code that uses <code>\PM\pM</code> to ï¬nd grapheme clusters instead of using
<code>\X</code> is broken and wrong.

</li></ul></div>
<div class="slide">
<h1>Appendix 1: Font suggestions

</h1><a name=appendix1_fonts>
</a>

<ul><li>
I recommend 
two free fonts from George
Douros at
<A HREF="http://users.teilar.gr/~g1951d/">
users.teilar.gr/~g1951d/</a> 
known to work with this presentation: his <i>Al&#64257;os</i> font for regular
text, and his <i>Symbola</i> font for fancy emoji.
If any of these don&#8217;t look right to you, you probably need to 
supplement your system fonts:
<ul>

<li>Ligatures: 
    <font face="'Arno Pro', Alfios,  Pali, Serif">
        &#64257; &#64259; &#64256; &#64260; &#64258; &#946; &#7838; &#64261;  &#64262; 
    </font>

<li>Math letters: 
    <font face="Symbola, Serif">
        &#119964; &#119967; &#120069; &#120078; &#120124; &#120125; 
    </font>

<li>Gothic <i>&</i> Deseret: 
    <font face="Symbola, Serif">
&#66360;&#66364;&#66365;&#66370;, &#66580;&#66607;&#66629;&#66600;&#66633;&#66607;&#66619;
    </font>

<li>Symbols: 
    <font face="Symbola, Sans">
        &#10004; &#9989; &#128042; &#128214; &#128706; &#128013; 
    </font>

<li>Emotica: 
    <font face="Symbola, Sans">
        &#128519; &#128520; &#128521; &#128552; &#128557; &#128561; 
    </font>

<li>Upside&#8208;down:
    <font size=2 face="Monaco, Mono">
        &#161;p&#592;&#601;&#613; &#633;no&#654; uo &#387;u&#7433;pu&#592;&#647;s &#654;q s&#7433;&#613;&#647; p&#592;&#601;&#7450;
    </font>

<li>Combining characters: 


    <font face="Monaco, 'Everson Mono', Mono">
&#9676;&#770;,&#9676;&#771;,&#9676;&#8414;,&#9676;&#818;,&#9676;&#65024;,&#9676;&#821;,&#9676;&#823;
    </font>

</ul>
<li>The last line with combining characters is especially hard to get to
look right.  You may &#64257;nd that the shareware font <i>Everson Mono</i>
works when all else fails.

</ul>

</div>
<div class="slide">
<h1>Appendix 2: Tools

</h1><ul>
<li>
I wrote a huge bucketful of tools to make your life with Unicode not just easier, but more fun.
<li>These are available in 
the <a href="http://search.cpan.org/perldoc?Unicode::Tussle" target=_blank>Unicode::Tussle</a> bundle from CPAN,
where they come with <a href="http://search.cpan.org/perldoc?Unicode::Tussle" target=_blank>documentation</a>,
or you can get them individually 
from <a href="http://training.perl.com/scripts/" target=_blank>training.perl.com/scripts</a> if you&#8217;d prefer.

<li>
Thanks very much to <i>brian d foy</i> for putting that CPAN bundle together for me.
</ul>

</div>
<div class="slide">
<h1>Contact Information

</h1><ul>
<li>
Iâ€™m Tom Christiansen.  You can reach me at <A HREF="mailto:tchrist@perl.com">tchrist@perl.com</a>.
<li>
All three talks, as well as these instructions, are available from 
<a  href="http://training.perl.com/OSCON2011/index.html">
training.perl.com/OSCON2011</a>.
</ul>

</div>
<div class="slide">
<h1>YANETUT

</h1><p>æ–‡å­—åŒ–ã‘ 
ğ€¬
ğ€³
ğ€µ
ğ€·
ğ€º
ğ
ğ©
ğ­
ğ²
ğ„
ğ„ƒ
ğ„ˆ
ğ„
ğ„
ğ„’
ğ„”
ğ„—
ğ„™
ğ„¬
ğ„¯
ğ„±
ğ„µ
ğ„¹
ğ„»
ğ…€
ğ…¤
ğ…«
ğ†„
ğ†’
ğ†•
ğ†—
ğ†š
ğ†¶
ğ†»
ğ‡€
ğŸ€€
ğŸ€„
ğŸ€ˆ
ğŸ€‹
ğŸ€
ğŸ€
ğŸ€’
ğŸ€•
ğŸ€š
ğŸ€
ğŸ€ 
ğŸ€£
ğŸ€¦
ğŸ€¨
ğŸ€«
ğŸ‚©
ğŸ‚¬
ğŸ‚®
ğŸ‚±
ğŸ‚µ
ğŸ‚º
ğŸ‚¼
ğŸƒ
ğŸƒƒ
ğŸƒ†
ğŸƒˆ
ğŸƒ
ğŸƒ“
ğŸƒ•
ğŸƒ˜
ğŸƒš
ğŸƒ
ğŸƒŸ
ğŸŒ€
ğŸŒ
ğŸŒ‚
ğŸŒƒ
ğŸŒ„
ğŸŒ…
ğŸŒ†
ğŸŒ‡
ğŸŒˆ
ğŸŒ‰
ğŸŒŠ
ğŸŒ‹
ğŸŒŒ
ğŸŒ
ğŸŒ
ğŸŒ
ğŸŒ
ğŸŒ‘
ğŸŒ’
ğŸŒ“
ğŸŒ”
ğŸŒ•
ğŸŒ–
ğŸŒ—
ğŸŒ˜
ğŸŒ™
ğŸŒš
ğŸŒ›
ğŸŒœ
ğŸŒ
ğŸŒ
ğŸŒŸ
ğŸŒ 
ğŸŒ°
ğŸŒ±
ğŸŒ²
ğŸŒ³
ğŸŒ´
ğŸŒµ
ğŸŒ·
ğŸŒ¸
ğŸŒ¹
ğŸŒº
ğŸŒ»
ğŸŒ¼
ğŸŒ½
ğŸŒ¾
ğŸŒ¿
ğŸ€
ğŸ
ğŸ‚
ğŸƒ
ğŸ„
ğŸ…
ğŸ†
ğŸ‡
ğŸˆ
ğŸ‰
ğŸŠ
ğŸ‹
ğŸŒ
ğŸ
ğŸ
ğŸ
ğŸ
ğŸ‘
ğŸ’
ğŸ“
ğŸ”
ğŸ•
ğŸ–
ğŸ—
ğŸ˜
ğŸ™
ğŸš
ğŸ›
ğŸœ
ğŸ
ğŸ
ğŸŸ
ğŸ 
ğŸ¡
ğŸ¢
ğŸ£
ğŸ¤
ğŸ¥
ğŸ¦
ğŸ§
ğŸ¨
ğŸ©
ğŸª
ğŸ«
ğŸ¬
ğŸ­
ğŸ®
ğŸ¯
ğŸ°
ğŸ±
ğŸ²
ğŸ³
ğŸ´
ğŸµ
ğŸ¶
ğŸ·
ğŸ¸
ğŸ¹
ğŸº
ğŸ»
ğŸ¼
ğŸ€
ğŸ
ğŸ‚
ğŸƒ
ğŸ„
ğŸ…
ğŸ†
ğŸ‡
ğŸˆ
ğŸ‰
ğŸŠ
ğŸ‹
ğŸŒ
ğŸ
ğŸ
ğŸ
ğŸ
ğŸ‘
ğŸ’
ğŸ“
ğŸ 
ğŸ¡
ğŸ¢
ğŸ£
ğŸ¤
ğŸ¥
ğŸ¦
ğŸ§
ğŸ¨
ğŸ©
ğŸª
ğŸ«
ğŸ¬
ğŸ­
ğŸ®
ğŸ¯
ğŸ°
ğŸ±
ğŸ²
ğŸ³
ğŸ´
ğŸµ
ğŸ¶
ğŸ·
ğŸ¸
ğŸ¹
ğŸº
ğŸ»
ğŸ¼
ğŸ½
ğŸ¾
ğŸ¿
ğŸ€
ğŸ
ğŸ‚
ğŸƒ
ğŸ„
ğŸ†
ğŸ‡
ğŸˆ
ğŸ‰
ğŸŠ
ğŸ 
ğŸ¡
ğŸ¢
ğŸ£
ğŸ¤
ğŸ¥
ğŸ¦
ğŸ§
ğŸ¨
ğŸ©
ğŸª
ğŸ«
ğŸ¬
ğŸ­
ğŸ®
ğŸ¯
ğŸ°
ğŸ€
ğŸ
ğŸ‚
ğŸƒ
ğŸ„
ğŸ…
ğŸ†
ğŸ‡
ğŸˆ
ğŸ‰
ğŸŠ
ğŸ‹
ğŸŒ
ğŸ
ğŸ
ğŸ
ğŸ
ğŸ‘
ğŸ’
ğŸ“
ğŸ”
ğŸ•
ğŸ–
ğŸ—
ğŸ˜
ğŸ™
ğŸš
ğŸ›
ğŸœ
ğŸ
ğŸ
ğŸŸ
ğŸ 
ğŸ¡
ğŸ¢
ğŸ£
ğŸ¤
ğŸ¥
ğŸ¦
ğŸ§
ğŸ¨
ğŸ©
ğŸª
ğŸ«
ğŸ¬
ğŸ­
ğŸ®
ğŸ¯
ğŸ°
ğŸ±
ğŸ²
ğŸ³
ğŸ´
ğŸµ
ğŸ¶
ğŸ·
ğŸ¸
ğŸ¹
ğŸº
ğŸ»
ğŸ¼
ğŸ½
ğŸ¾
ğŸ‘€
ğŸ‘‚
ğŸ‘ƒ
ğŸ‘„
ğŸ‘…
ğŸ‘†
ğŸ‘‡
ğŸ‘ˆ
ğŸ‘‰
ğŸ‘Š
ğŸ‘‹
ğŸ‘Œ
ğŸ‘
ğŸ‘
ğŸ‘
ğŸ‘
ğŸ‘‘
ğŸ‘’
ğŸ‘“
ğŸ‘”
ğŸ‘•
ğŸ‘–
ğŸ‘—
ğŸ‘˜
ğŸ‘™
ğŸ‘š
ğŸ‘›
ğŸ‘œ
ğŸ‘
ğŸ‘
ğŸ‘Ÿ
ğŸ‘ 
ğŸ‘¡
ğŸ‘¢
ğŸ‘£
ğŸ‘¤
ğŸ‘¥
ğŸ‘¦
ğŸ‘§
ğŸ‘¨
ğŸ‘©
ğŸ‘ª
ğŸ‘«
ğŸ‘¬
ğŸ‘­
ğŸ‘®
ğŸ‘¯
ğŸ‘°
ğŸ‘±
ğŸ‘²
ğŸ‘³
ğŸ‘´
ğŸ‘µ
ğŸ‘¶
ğŸ‘·
ğŸ‘¸
ğŸ‘¹
ğŸ‘º
ğŸ‘»
ğŸ‘¼
ğŸ‘½
ğŸ‘¾
ğŸ‘¿
ğŸ’€
ğŸ’
ğŸ’‚
ğŸ’ƒ
ğŸ’„
ğŸ’…
ğŸ’†
ğŸ’‡
ğŸ’ˆ
ğŸ’‰
ğŸ’Š
ğŸ’‹
ğŸ’Œ
ğŸ’
ğŸ’
ğŸ’
ğŸ’
ğŸ’‘
ğŸ’’
ğŸ’“
ğŸ’”
ğŸ’•
ğŸ’–
ğŸ’—
ğŸ’˜
ğŸ’™
ğŸ’š
ğŸ’›
ğŸ’œ
ğŸ’
ğŸ’
ğŸ’Ÿ
ğŸ’ 
ğŸ’¡
ğŸ’¢
ğŸ’£
ğŸ’¤
ğŸ’¥
ğŸ’¦
ğŸ’§
ğŸ’¨
ğŸ’©
ğŸ’ª
ğŸ’«
ğŸ’¬
ğŸ’­
ğŸ’®
ğŸ’¯
ğŸ’°
ğŸ’±
ğŸ’²
ğŸ’³
ğŸ’´
ğŸ’µ
ğŸ’¶
ğŸ’·
ğŸ’¸
ğŸ’¹
ğŸ’º
ğŸ’»
ğŸ’¼
ğŸ’½
ğŸ’¾
ğŸ’¿
ğŸ“€
ğŸ“
ğŸ“‚
ğŸ“ƒ
ğŸ“„
ğŸ“…
ğŸ“†
ğŸ“‡
ğŸ“ˆ
ğŸ“‰
ğŸ“Š
ğŸ“‹
ğŸ“Œ
ğŸ“
ğŸ“
ğŸ“
ğŸ“
ğŸ“‘
ğŸ“’
ğŸ““
ğŸ“”
ğŸ“•
ğŸ“–
ğŸ“—
ğŸ“˜
ğŸ“™
ğŸ“š
ğŸ“›
ğŸ“œ
ğŸ“
ğŸ“
ğŸ“Ÿ
ğŸ“ 
ğŸ“¡
ğŸ“¢
ğŸ“£
ğŸ“¤
ğŸ“¥
ğŸ“¦
ğŸ“§
ğŸ“¨
ğŸ“©
ğŸ“ª
ğŸ“«
ğŸ“¬
ğŸ“­
ğŸ“®
ğŸ“¯
ğŸ“°
ğŸ“±
ğŸ“²
ğŸ“³
ğŸ“´
ğŸ“µ
ğŸ“¶
ğŸ“·
ğŸ“¹
ğŸ“º
ğŸ“»
ğŸ“¼
ğŸ”€
ğŸ”
ğŸ”‚
ğŸ”ƒ
ğŸ”„
ğŸ”…
ğŸ”†
ğŸ”‡
ğŸ”ˆ
ğŸ”‰
ğŸ”Š
ğŸ”‹
ğŸ”Œ
ğŸ”
ğŸ”
ğŸ”
ğŸ”
ğŸ”‘
ğŸ”’
ğŸ”“
ğŸ””
ğŸ”•
ğŸ”–
ğŸ”—
ğŸ”˜
ğŸ”™
ğŸ”š
ğŸ”›
ğŸ”œ
ğŸ”
ğŸ”
ğŸ”Ÿ
ğŸ” 
ğŸ”¡
ğŸ”¢
ğŸ”£
ğŸ”¤
ğŸ”¥
ğŸ”¦
ğŸ”§
ğŸ”¨
ğŸ”©
ğŸ”ª
ğŸ”«
ğŸ”¬
ğŸ”­
ğŸ”®
ğŸ”¯
ğŸ”°
ğŸ”±
ğŸ”²
ğŸ”³
ğŸ”´
ğŸ”µ
ğŸ”¶
ğŸ”·
ğŸ”¸
ğŸ”¹
ğŸ”º
ğŸ”»
ğŸ”¼
ğŸ”½
ğŸ•
ğŸ•‘
ğŸ•’
ğŸ•“
ğŸ•”
ğŸ••
ğŸ•–
ğŸ•—
ğŸ•˜
ğŸ•™
ğŸ•š
ğŸ•›
ğŸ•œ
ğŸ•
ğŸ•
ğŸ•Ÿ
ğŸ• 
ğŸ•¡
ğŸ•¢
ğŸ•£
ğŸ•¤
ğŸ•¥
ğŸ•¦
ğŸ•§
ğŸ—»
ğŸ—¼
ğŸ—½
ğŸ—¾
ğŸ—¿
ğŸ˜
ğŸ˜‚
ğŸ˜ƒ
ğŸ˜„
ğŸ˜…
ğŸ˜†
ğŸ˜‡
ğŸ˜ˆ
ğŸ˜‰
ğŸ˜Š
ğŸ˜‹
ğŸ˜Œ
ğŸ˜
ğŸ˜
ğŸ˜
ğŸ˜
ğŸ˜’
ğŸ˜“
ğŸ˜”
ğŸ˜–
ğŸ˜˜
ğŸ˜š
ğŸ˜œ
ğŸ˜
ğŸ˜
ğŸ˜ 
ğŸ˜¡
ğŸ˜¢
ğŸ˜£
ğŸ˜¤
ğŸ˜¥
ğŸ˜¨
ğŸ˜©
ğŸ˜ª
ğŸ˜«
ğŸ˜­
ğŸ˜°
ğŸ˜±
ğŸ˜²
ğŸ˜³
ğŸ˜µ
ğŸ˜¶
ğŸ˜·
ğŸ˜¸
ğŸ˜¹
ğŸ˜º
ğŸ˜»
ğŸ˜¼
ğŸ˜½
ğŸ˜¾
ğŸ˜¿
ğŸ™€
ğŸ™…
ğŸ™†
ğŸ™Š
ğŸ™
ğŸ™
ğŸš
ğŸšƒ
ğŸš‡
ğŸšˆ
ğŸšŒ
ğŸš
ğŸš‘
ğŸš”
ğŸš–
ğŸš™
ğŸš
ğŸš¢
ğŸš¤
ğŸš§
ğŸšª
ğŸš¬
ğŸš¯
ğŸš³
ğŸš¸
ğŸœ‚
ğŸœƒ
ğŸœ‡
ğŸœˆ
ğŸœ
ğŸœ“
ğŸœ•
ğŸœ˜
ğŸœ
ğŸœ¡
ğŸœ¤
ğŸœ¦
ğŸœ©
ğŸœ«
ğŸœ®
ğŸœ²
ğŸœ³
ğŸœ·
ğŸœº
ğŸœ¼
ğŸœ¿
ğŸ
ğŸˆ
ğŸŒ
ğŸ
ğŸ
ğŸ’
ğŸ—
ğŸŸ
ğŸ¢
ğŸ©
ğŸ®
ğŸ°
ğŸ³
ã€ 
ê£
ğŒ´
ğŒ¶
ğŒ¹
ğŒ»
ğŒ¾
ğƒ
ğ„
ğˆ
ğŠ
ğ’‚Š
ğ’‚­
ğ’‚±
ğ’ƒ”
ğ’‡‰
ğ’‹§
ğ’‹¼
ğ’Œ£

</p></li></ul></li></ul></li></ul></li></div></body></html>




<!--
     FILE ARCHIVED ON 11:41:28 Nov 4, 2012 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 0:28:30 Nov 25, 2015.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
